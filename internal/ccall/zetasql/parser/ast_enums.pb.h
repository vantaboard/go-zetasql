// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: googlesql/parser/ast_enums.proto
// Protobuf C++ Version: 5.29.0

#ifndef googlesql_2fparser_2fast_5fenums_2eproto_2epb_2eh
#define googlesql_2fparser_2fast_5fenums_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_googlesql_2fparser_2fast_5fenums_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_googlesql_2fparser_2fast_5fenums_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_googlesql_2fparser_2fast_5fenums_2eproto;
namespace googlesql {
class ASTAfterMatchSkipClauseEnums;
struct ASTAfterMatchSkipClauseEnumsDefaultTypeInternal;
extern ASTAfterMatchSkipClauseEnumsDefaultTypeInternal _ASTAfterMatchSkipClauseEnums_default_instance_;
class ASTAlterIndexStatementEnums;
struct ASTAlterIndexStatementEnumsDefaultTypeInternal;
extern ASTAlterIndexStatementEnumsDefaultTypeInternal _ASTAlterIndexStatementEnums_default_instance_;
class ASTAnySomeAllOpEnums;
struct ASTAnySomeAllOpEnumsDefaultTypeInternal;
extern ASTAnySomeAllOpEnumsDefaultTypeInternal _ASTAnySomeAllOpEnums_default_instance_;
class ASTAuxLoadDataStatementEnums;
struct ASTAuxLoadDataStatementEnumsDefaultTypeInternal;
extern ASTAuxLoadDataStatementEnumsDefaultTypeInternal _ASTAuxLoadDataStatementEnums_default_instance_;
class ASTBinaryExpressionEnums;
struct ASTBinaryExpressionEnumsDefaultTypeInternal;
extern ASTBinaryExpressionEnumsDefaultTypeInternal _ASTBinaryExpressionEnums_default_instance_;
class ASTBracedConstructorLhsEnums;
struct ASTBracedConstructorLhsEnumsDefaultTypeInternal;
extern ASTBracedConstructorLhsEnumsDefaultTypeInternal _ASTBracedConstructorLhsEnums_default_instance_;
class ASTBreakContinueStatementEnums;
struct ASTBreakContinueStatementEnumsDefaultTypeInternal;
extern ASTBreakContinueStatementEnumsDefaultTypeInternal _ASTBreakContinueStatementEnums_default_instance_;
class ASTColumnPositionEnums;
struct ASTColumnPositionEnumsDefaultTypeInternal;
extern ASTColumnPositionEnumsDefaultTypeInternal _ASTColumnPositionEnums_default_instance_;
class ASTCreateFunctionStmtBaseEnums;
struct ASTCreateFunctionStmtBaseEnumsDefaultTypeInternal;
extern ASTCreateFunctionStmtBaseEnumsDefaultTypeInternal _ASTCreateFunctionStmtBaseEnums_default_instance_;
class ASTCreateStatementEnums;
struct ASTCreateStatementEnumsDefaultTypeInternal;
extern ASTCreateStatementEnumsDefaultTypeInternal _ASTCreateStatementEnums_default_instance_;
class ASTDropStatementEnums;
struct ASTDropStatementEnumsDefaultTypeInternal;
extern ASTDropStatementEnumsDefaultTypeInternal _ASTDropStatementEnums_default_instance_;
class ASTExpressionSubqueryEnums;
struct ASTExpressionSubqueryEnumsDefaultTypeInternal;
extern ASTExpressionSubqueryEnumsDefaultTypeInternal _ASTExpressionSubqueryEnums_default_instance_;
class ASTFilterFieldsArgEnums;
struct ASTFilterFieldsArgEnumsDefaultTypeInternal;
extern ASTFilterFieldsArgEnumsDefaultTypeInternal _ASTFilterFieldsArgEnums_default_instance_;
class ASTForeignKeyActionsEnums;
struct ASTForeignKeyActionsEnumsDefaultTypeInternal;
extern ASTForeignKeyActionsEnumsDefaultTypeInternal _ASTForeignKeyActionsEnums_default_instance_;
class ASTForeignKeyReferenceEnums;
struct ASTForeignKeyReferenceEnumsDefaultTypeInternal;
extern ASTForeignKeyReferenceEnumsDefaultTypeInternal _ASTForeignKeyReferenceEnums_default_instance_;
class ASTFunctionCallEnums;
struct ASTFunctionCallEnumsDefaultTypeInternal;
extern ASTFunctionCallEnumsDefaultTypeInternal _ASTFunctionCallEnums_default_instance_;
class ASTFunctionParameterEnums;
struct ASTFunctionParameterEnumsDefaultTypeInternal;
extern ASTFunctionParameterEnumsDefaultTypeInternal _ASTFunctionParameterEnums_default_instance_;
class ASTGeneratedColumnInfoEnums;
struct ASTGeneratedColumnInfoEnumsDefaultTypeInternal;
extern ASTGeneratedColumnInfoEnumsDefaultTypeInternal _ASTGeneratedColumnInfoEnums_default_instance_;
class ASTGraphEdgePatternEnums;
struct ASTGraphEdgePatternEnumsDefaultTypeInternal;
extern ASTGraphEdgePatternEnumsDefaultTypeInternal _ASTGraphEdgePatternEnums_default_instance_;
class ASTGraphLabelOperationEnums;
struct ASTGraphLabelOperationEnumsDefaultTypeInternal;
extern ASTGraphLabelOperationEnumsDefaultTypeInternal _ASTGraphLabelOperationEnums_default_instance_;
class ASTGraphNodeTableReferenceEnums;
struct ASTGraphNodeTableReferenceEnumsDefaultTypeInternal;
extern ASTGraphNodeTableReferenceEnumsDefaultTypeInternal _ASTGraphNodeTableReferenceEnums_default_instance_;
class ASTGraphPathModeEnums;
struct ASTGraphPathModeEnumsDefaultTypeInternal;
extern ASTGraphPathModeEnumsDefaultTypeInternal _ASTGraphPathModeEnums_default_instance_;
class ASTGraphPathSearchPrefixEnums;
struct ASTGraphPathSearchPrefixEnumsDefaultTypeInternal;
extern ASTGraphPathSearchPrefixEnumsDefaultTypeInternal _ASTGraphPathSearchPrefixEnums_default_instance_;
class ASTHavingModifierEnums;
struct ASTHavingModifierEnumsDefaultTypeInternal;
extern ASTHavingModifierEnumsDefaultTypeInternal _ASTHavingModifierEnums_default_instance_;
class ASTImportStatementEnums;
struct ASTImportStatementEnumsDefaultTypeInternal;
extern ASTImportStatementEnumsDefaultTypeInternal _ASTImportStatementEnums_default_instance_;
class ASTInsertStatementEnums;
struct ASTInsertStatementEnumsDefaultTypeInternal;
extern ASTInsertStatementEnumsDefaultTypeInternal _ASTInsertStatementEnums_default_instance_;
class ASTJoinEnums;
struct ASTJoinEnumsDefaultTypeInternal;
extern ASTJoinEnumsDefaultTypeInternal _ASTJoinEnums_default_instance_;
class ASTLockModeEnums;
struct ASTLockModeEnumsDefaultTypeInternal;
extern ASTLockModeEnumsDefaultTypeInternal _ASTLockModeEnums_default_instance_;
class ASTMergeActionEnums;
struct ASTMergeActionEnumsDefaultTypeInternal;
extern ASTMergeActionEnumsDefaultTypeInternal _ASTMergeActionEnums_default_instance_;
class ASTMergeWhenClauseEnums;
struct ASTMergeWhenClauseEnumsDefaultTypeInternal;
extern ASTMergeWhenClauseEnumsDefaultTypeInternal _ASTMergeWhenClauseEnums_default_instance_;
class ASTOnConflictClauseEnums;
struct ASTOnConflictClauseEnumsDefaultTypeInternal;
extern ASTOnConflictClauseEnumsDefaultTypeInternal _ASTOnConflictClauseEnums_default_instance_;
class ASTOptionsEntryEnums;
struct ASTOptionsEntryEnumsDefaultTypeInternal;
extern ASTOptionsEntryEnumsDefaultTypeInternal _ASTOptionsEntryEnums_default_instance_;
class ASTOrderingExpressionEnums;
struct ASTOrderingExpressionEnumsDefaultTypeInternal;
extern ASTOrderingExpressionEnumsDefaultTypeInternal _ASTOrderingExpressionEnums_default_instance_;
class ASTRowPatternAnchorEnums;
struct ASTRowPatternAnchorEnumsDefaultTypeInternal;
extern ASTRowPatternAnchorEnumsDefaultTypeInternal _ASTRowPatternAnchorEnums_default_instance_;
class ASTRowPatternOperationEnums;
struct ASTRowPatternOperationEnumsDefaultTypeInternal;
extern ASTRowPatternOperationEnumsDefaultTypeInternal _ASTRowPatternOperationEnums_default_instance_;
class ASTSampleSizeEnums;
struct ASTSampleSizeEnumsDefaultTypeInternal;
extern ASTSampleSizeEnumsDefaultTypeInternal _ASTSampleSizeEnums_default_instance_;
class ASTSelectAsEnums;
struct ASTSelectAsEnumsDefaultTypeInternal;
extern ASTSelectAsEnumsDefaultTypeInternal _ASTSelectAsEnums_default_instance_;
class ASTSetOperationEnums;
struct ASTSetOperationEnumsDefaultTypeInternal;
extern ASTSetOperationEnumsDefaultTypeInternal _ASTSetOperationEnums_default_instance_;
class ASTSpannerInterleaveClauseEnums;
struct ASTSpannerInterleaveClauseEnumsDefaultTypeInternal;
extern ASTSpannerInterleaveClauseEnumsDefaultTypeInternal _ASTSpannerInterleaveClauseEnums_default_instance_;
class ASTSymbolQuantifierEnums;
struct ASTSymbolQuantifierEnumsDefaultTypeInternal;
extern ASTSymbolQuantifierEnumsDefaultTypeInternal _ASTSymbolQuantifierEnums_default_instance_;
class ASTTemplatedParameterTypeEnums;
struct ASTTemplatedParameterTypeEnumsDefaultTypeInternal;
extern ASTTemplatedParameterTypeEnumsDefaultTypeInternal _ASTTemplatedParameterTypeEnums_default_instance_;
class ASTTransactionReadWriteModeEnums;
struct ASTTransactionReadWriteModeEnumsDefaultTypeInternal;
extern ASTTransactionReadWriteModeEnumsDefaultTypeInternal _ASTTransactionReadWriteModeEnums_default_instance_;
class ASTUnaryExpressionEnums;
struct ASTUnaryExpressionEnumsDefaultTypeInternal;
extern ASTUnaryExpressionEnumsDefaultTypeInternal _ASTUnaryExpressionEnums_default_instance_;
class ASTUnpivotClauseEnums;
struct ASTUnpivotClauseEnumsDefaultTypeInternal;
extern ASTUnpivotClauseEnumsDefaultTypeInternal _ASTUnpivotClauseEnums_default_instance_;
class ASTWindowFrameEnums;
struct ASTWindowFrameEnumsDefaultTypeInternal;
extern ASTWindowFrameEnumsDefaultTypeInternal _ASTWindowFrameEnums_default_instance_;
class ASTWindowFrameExprEnums;
struct ASTWindowFrameExprEnumsDefaultTypeInternal;
extern ASTWindowFrameExprEnumsDefaultTypeInternal _ASTWindowFrameExprEnums_default_instance_;
}  // namespace googlesql
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace googlesql {
enum ASTBinaryExpressionEnums_Op : int {
  ASTBinaryExpressionEnums_Op_NOT_SET = 0,
  ASTBinaryExpressionEnums_Op_LIKE = 1,
  ASTBinaryExpressionEnums_Op_IS = 2,
  ASTBinaryExpressionEnums_Op_EQ = 3,
  ASTBinaryExpressionEnums_Op_NE = 4,
  ASTBinaryExpressionEnums_Op_NE2 = 5,
  ASTBinaryExpressionEnums_Op_GT = 6,
  ASTBinaryExpressionEnums_Op_LT = 7,
  ASTBinaryExpressionEnums_Op_GE = 8,
  ASTBinaryExpressionEnums_Op_LE = 9,
  ASTBinaryExpressionEnums_Op_BITWISE_OR = 10,
  ASTBinaryExpressionEnums_Op_BITWISE_XOR = 11,
  ASTBinaryExpressionEnums_Op_BITWISE_AND = 12,
  ASTBinaryExpressionEnums_Op_PLUS = 13,
  ASTBinaryExpressionEnums_Op_MINUS = 14,
  ASTBinaryExpressionEnums_Op_MULTIPLY = 15,
  ASTBinaryExpressionEnums_Op_DIVIDE = 16,
  ASTBinaryExpressionEnums_Op_CONCAT_OP = 17,
  ASTBinaryExpressionEnums_Op_DISTINCT = 18,
  ASTBinaryExpressionEnums_Op_IS_SOURCE_NODE = 19,
  ASTBinaryExpressionEnums_Op_IS_DEST_NODE = 20,
};

bool ASTBinaryExpressionEnums_Op_IsValid(int value);
extern const uint32_t ASTBinaryExpressionEnums_Op_internal_data_[];
constexpr ASTBinaryExpressionEnums_Op ASTBinaryExpressionEnums_Op_Op_MIN = static_cast<ASTBinaryExpressionEnums_Op>(0);
constexpr ASTBinaryExpressionEnums_Op ASTBinaryExpressionEnums_Op_Op_MAX = static_cast<ASTBinaryExpressionEnums_Op>(20);
constexpr int ASTBinaryExpressionEnums_Op_Op_ARRAYSIZE = 20 + 1;
const ::google::protobuf::EnumDescriptor*
ASTBinaryExpressionEnums_Op_descriptor();
template <typename T>
const std::string& ASTBinaryExpressionEnums_Op_Name(T value) {
  static_assert(std::is_same<T, ASTBinaryExpressionEnums_Op>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Op_Name().");
  return ASTBinaryExpressionEnums_Op_Name(static_cast<ASTBinaryExpressionEnums_Op>(value));
}
template <>
inline const std::string& ASTBinaryExpressionEnums_Op_Name(ASTBinaryExpressionEnums_Op value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTBinaryExpressionEnums_Op_descriptor,
                                                 0, 20>(
      static_cast<int>(value));
}
inline bool ASTBinaryExpressionEnums_Op_Parse(absl::string_view name, ASTBinaryExpressionEnums_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTBinaryExpressionEnums_Op>(
      ASTBinaryExpressionEnums_Op_descriptor(), name, value);
}
enum ASTOptionsEntryEnums_AssignmentOp : int {
  ASTOptionsEntryEnums_AssignmentOp_NOT_SET = 0,
  ASTOptionsEntryEnums_AssignmentOp_ASSIGN = 1,
  ASTOptionsEntryEnums_AssignmentOp_ADD_ASSIGN = 2,
  ASTOptionsEntryEnums_AssignmentOp_SUB_ASSIGN = 3,
};

bool ASTOptionsEntryEnums_AssignmentOp_IsValid(int value);
extern const uint32_t ASTOptionsEntryEnums_AssignmentOp_internal_data_[];
constexpr ASTOptionsEntryEnums_AssignmentOp ASTOptionsEntryEnums_AssignmentOp_AssignmentOp_MIN = static_cast<ASTOptionsEntryEnums_AssignmentOp>(0);
constexpr ASTOptionsEntryEnums_AssignmentOp ASTOptionsEntryEnums_AssignmentOp_AssignmentOp_MAX = static_cast<ASTOptionsEntryEnums_AssignmentOp>(3);
constexpr int ASTOptionsEntryEnums_AssignmentOp_AssignmentOp_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTOptionsEntryEnums_AssignmentOp_descriptor();
template <typename T>
const std::string& ASTOptionsEntryEnums_AssignmentOp_Name(T value) {
  static_assert(std::is_same<T, ASTOptionsEntryEnums_AssignmentOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AssignmentOp_Name().");
  return ASTOptionsEntryEnums_AssignmentOp_Name(static_cast<ASTOptionsEntryEnums_AssignmentOp>(value));
}
template <>
inline const std::string& ASTOptionsEntryEnums_AssignmentOp_Name(ASTOptionsEntryEnums_AssignmentOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTOptionsEntryEnums_AssignmentOp_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTOptionsEntryEnums_AssignmentOp_Parse(absl::string_view name, ASTOptionsEntryEnums_AssignmentOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTOptionsEntryEnums_AssignmentOp>(
      ASTOptionsEntryEnums_AssignmentOp_descriptor(), name, value);
}
enum ASTOrderingExpressionEnums_OrderingSpec : int {
  ASTOrderingExpressionEnums_OrderingSpec_NOT_SET = 0,
  ASTOrderingExpressionEnums_OrderingSpec_ASC = 1,
  ASTOrderingExpressionEnums_OrderingSpec_DESC = 2,
  ASTOrderingExpressionEnums_OrderingSpec_UNSPECIFIED = 3,
};

bool ASTOrderingExpressionEnums_OrderingSpec_IsValid(int value);
extern const uint32_t ASTOrderingExpressionEnums_OrderingSpec_internal_data_[];
constexpr ASTOrderingExpressionEnums_OrderingSpec ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MIN = static_cast<ASTOrderingExpressionEnums_OrderingSpec>(0);
constexpr ASTOrderingExpressionEnums_OrderingSpec ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MAX = static_cast<ASTOrderingExpressionEnums_OrderingSpec>(3);
constexpr int ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTOrderingExpressionEnums_OrderingSpec_descriptor();
template <typename T>
const std::string& ASTOrderingExpressionEnums_OrderingSpec_Name(T value) {
  static_assert(std::is_same<T, ASTOrderingExpressionEnums_OrderingSpec>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderingSpec_Name().");
  return ASTOrderingExpressionEnums_OrderingSpec_Name(static_cast<ASTOrderingExpressionEnums_OrderingSpec>(value));
}
template <>
inline const std::string& ASTOrderingExpressionEnums_OrderingSpec_Name(ASTOrderingExpressionEnums_OrderingSpec value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTOrderingExpressionEnums_OrderingSpec_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTOrderingExpressionEnums_OrderingSpec_Parse(absl::string_view name, ASTOrderingExpressionEnums_OrderingSpec* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTOrderingExpressionEnums_OrderingSpec>(
      ASTOrderingExpressionEnums_OrderingSpec_descriptor(), name, value);
}
enum ASTJoinEnums_JoinType : int {
  ASTJoinEnums_JoinType_DEFAULT_JOIN_TYPE = 0,
  ASTJoinEnums_JoinType_COMMA = 1,
  ASTJoinEnums_JoinType_CROSS = 2,
  ASTJoinEnums_JoinType_FULL = 3,
  ASTJoinEnums_JoinType_INNER = 4,
  ASTJoinEnums_JoinType_LEFT = 5,
  ASTJoinEnums_JoinType_RIGHT = 6,
};

bool ASTJoinEnums_JoinType_IsValid(int value);
extern const uint32_t ASTJoinEnums_JoinType_internal_data_[];
constexpr ASTJoinEnums_JoinType ASTJoinEnums_JoinType_JoinType_MIN = static_cast<ASTJoinEnums_JoinType>(0);
constexpr ASTJoinEnums_JoinType ASTJoinEnums_JoinType_JoinType_MAX = static_cast<ASTJoinEnums_JoinType>(6);
constexpr int ASTJoinEnums_JoinType_JoinType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ASTJoinEnums_JoinType_descriptor();
template <typename T>
const std::string& ASTJoinEnums_JoinType_Name(T value) {
  static_assert(std::is_same<T, ASTJoinEnums_JoinType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JoinType_Name().");
  return ASTJoinEnums_JoinType_Name(static_cast<ASTJoinEnums_JoinType>(value));
}
template <>
inline const std::string& ASTJoinEnums_JoinType_Name(ASTJoinEnums_JoinType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTJoinEnums_JoinType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ASTJoinEnums_JoinType_Parse(absl::string_view name, ASTJoinEnums_JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTJoinEnums_JoinType>(
      ASTJoinEnums_JoinType_descriptor(), name, value);
}
enum ASTJoinEnums_JoinHint : int {
  ASTJoinEnums_JoinHint_NO_JOIN_HINT = 0,
  ASTJoinEnums_JoinHint_HASH = 1,
  ASTJoinEnums_JoinHint_LOOKUP = 2,
};

bool ASTJoinEnums_JoinHint_IsValid(int value);
extern const uint32_t ASTJoinEnums_JoinHint_internal_data_[];
constexpr ASTJoinEnums_JoinHint ASTJoinEnums_JoinHint_JoinHint_MIN = static_cast<ASTJoinEnums_JoinHint>(0);
constexpr ASTJoinEnums_JoinHint ASTJoinEnums_JoinHint_JoinHint_MAX = static_cast<ASTJoinEnums_JoinHint>(2);
constexpr int ASTJoinEnums_JoinHint_JoinHint_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTJoinEnums_JoinHint_descriptor();
template <typename T>
const std::string& ASTJoinEnums_JoinHint_Name(T value) {
  static_assert(std::is_same<T, ASTJoinEnums_JoinHint>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JoinHint_Name().");
  return ASTJoinEnums_JoinHint_Name(static_cast<ASTJoinEnums_JoinHint>(value));
}
template <>
inline const std::string& ASTJoinEnums_JoinHint_Name(ASTJoinEnums_JoinHint value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTJoinEnums_JoinHint_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTJoinEnums_JoinHint_Parse(absl::string_view name, ASTJoinEnums_JoinHint* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTJoinEnums_JoinHint>(
      ASTJoinEnums_JoinHint_descriptor(), name, value);
}
enum ASTSelectAsEnums_AsMode : int {
  ASTSelectAsEnums_AsMode_NOT_SET = 0,
  ASTSelectAsEnums_AsMode_STRUCT = 1,
  ASTSelectAsEnums_AsMode_VALUE = 2,
  ASTSelectAsEnums_AsMode_TYPE_NAME = 3,
};

bool ASTSelectAsEnums_AsMode_IsValid(int value);
extern const uint32_t ASTSelectAsEnums_AsMode_internal_data_[];
constexpr ASTSelectAsEnums_AsMode ASTSelectAsEnums_AsMode_AsMode_MIN = static_cast<ASTSelectAsEnums_AsMode>(0);
constexpr ASTSelectAsEnums_AsMode ASTSelectAsEnums_AsMode_AsMode_MAX = static_cast<ASTSelectAsEnums_AsMode>(3);
constexpr int ASTSelectAsEnums_AsMode_AsMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTSelectAsEnums_AsMode_descriptor();
template <typename T>
const std::string& ASTSelectAsEnums_AsMode_Name(T value) {
  static_assert(std::is_same<T, ASTSelectAsEnums_AsMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AsMode_Name().");
  return ASTSelectAsEnums_AsMode_Name(static_cast<ASTSelectAsEnums_AsMode>(value));
}
template <>
inline const std::string& ASTSelectAsEnums_AsMode_Name(ASTSelectAsEnums_AsMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTSelectAsEnums_AsMode_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTSelectAsEnums_AsMode_Parse(absl::string_view name, ASTSelectAsEnums_AsMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTSelectAsEnums_AsMode>(
      ASTSelectAsEnums_AsMode_descriptor(), name, value);
}
enum ASTFunctionCallEnums_NullHandlingModifier : int {
  ASTFunctionCallEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING = 0,
  ASTFunctionCallEnums_NullHandlingModifier_IGNORE_NULLS = 1,
  ASTFunctionCallEnums_NullHandlingModifier_RESPECT_NULLS = 2,
};

bool ASTFunctionCallEnums_NullHandlingModifier_IsValid(int value);
extern const uint32_t ASTFunctionCallEnums_NullHandlingModifier_internal_data_[];
constexpr ASTFunctionCallEnums_NullHandlingModifier ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MIN = static_cast<ASTFunctionCallEnums_NullHandlingModifier>(0);
constexpr ASTFunctionCallEnums_NullHandlingModifier ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MAX = static_cast<ASTFunctionCallEnums_NullHandlingModifier>(2);
constexpr int ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTFunctionCallEnums_NullHandlingModifier_descriptor();
template <typename T>
const std::string& ASTFunctionCallEnums_NullHandlingModifier_Name(T value) {
  static_assert(std::is_same<T, ASTFunctionCallEnums_NullHandlingModifier>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NullHandlingModifier_Name().");
  return ASTFunctionCallEnums_NullHandlingModifier_Name(static_cast<ASTFunctionCallEnums_NullHandlingModifier>(value));
}
template <>
inline const std::string& ASTFunctionCallEnums_NullHandlingModifier_Name(ASTFunctionCallEnums_NullHandlingModifier value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTFunctionCallEnums_NullHandlingModifier_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTFunctionCallEnums_NullHandlingModifier_Parse(absl::string_view name, ASTFunctionCallEnums_NullHandlingModifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTFunctionCallEnums_NullHandlingModifier>(
      ASTFunctionCallEnums_NullHandlingModifier_descriptor(), name, value);
}
enum ASTExpressionSubqueryEnums_Modifier : int {
  ASTExpressionSubqueryEnums_Modifier_NONE = 0,
  ASTExpressionSubqueryEnums_Modifier_ARRAY = 1,
  ASTExpressionSubqueryEnums_Modifier_EXISTS = 2,
  ASTExpressionSubqueryEnums_Modifier_VALUE = 3,
};

bool ASTExpressionSubqueryEnums_Modifier_IsValid(int value);
extern const uint32_t ASTExpressionSubqueryEnums_Modifier_internal_data_[];
constexpr ASTExpressionSubqueryEnums_Modifier ASTExpressionSubqueryEnums_Modifier_Modifier_MIN = static_cast<ASTExpressionSubqueryEnums_Modifier>(0);
constexpr ASTExpressionSubqueryEnums_Modifier ASTExpressionSubqueryEnums_Modifier_Modifier_MAX = static_cast<ASTExpressionSubqueryEnums_Modifier>(3);
constexpr int ASTExpressionSubqueryEnums_Modifier_Modifier_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTExpressionSubqueryEnums_Modifier_descriptor();
template <typename T>
const std::string& ASTExpressionSubqueryEnums_Modifier_Name(T value) {
  static_assert(std::is_same<T, ASTExpressionSubqueryEnums_Modifier>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Modifier_Name().");
  return ASTExpressionSubqueryEnums_Modifier_Name(static_cast<ASTExpressionSubqueryEnums_Modifier>(value));
}
template <>
inline const std::string& ASTExpressionSubqueryEnums_Modifier_Name(ASTExpressionSubqueryEnums_Modifier value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTExpressionSubqueryEnums_Modifier_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTExpressionSubqueryEnums_Modifier_Parse(absl::string_view name, ASTExpressionSubqueryEnums_Modifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTExpressionSubqueryEnums_Modifier>(
      ASTExpressionSubqueryEnums_Modifier_descriptor(), name, value);
}
enum ASTHavingModifierEnums_ModifierKind : int {
  ASTHavingModifierEnums_ModifierKind_NOT_SET = 0,
  ASTHavingModifierEnums_ModifierKind_MIN = 1,
  ASTHavingModifierEnums_ModifierKind_MAX = 2,
};

bool ASTHavingModifierEnums_ModifierKind_IsValid(int value);
extern const uint32_t ASTHavingModifierEnums_ModifierKind_internal_data_[];
constexpr ASTHavingModifierEnums_ModifierKind ASTHavingModifierEnums_ModifierKind_ModifierKind_MIN = static_cast<ASTHavingModifierEnums_ModifierKind>(0);
constexpr ASTHavingModifierEnums_ModifierKind ASTHavingModifierEnums_ModifierKind_ModifierKind_MAX = static_cast<ASTHavingModifierEnums_ModifierKind>(2);
constexpr int ASTHavingModifierEnums_ModifierKind_ModifierKind_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTHavingModifierEnums_ModifierKind_descriptor();
template <typename T>
const std::string& ASTHavingModifierEnums_ModifierKind_Name(T value) {
  static_assert(std::is_same<T, ASTHavingModifierEnums_ModifierKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ModifierKind_Name().");
  return ASTHavingModifierEnums_ModifierKind_Name(static_cast<ASTHavingModifierEnums_ModifierKind>(value));
}
template <>
inline const std::string& ASTHavingModifierEnums_ModifierKind_Name(ASTHavingModifierEnums_ModifierKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTHavingModifierEnums_ModifierKind_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTHavingModifierEnums_ModifierKind_Parse(absl::string_view name, ASTHavingModifierEnums_ModifierKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTHavingModifierEnums_ModifierKind>(
      ASTHavingModifierEnums_ModifierKind_descriptor(), name, value);
}
enum ASTSetOperationEnums_OperationType : int {
  ASTSetOperationEnums_OperationType_NOT_SET = 0,
  ASTSetOperationEnums_OperationType_UNION = 1,
  ASTSetOperationEnums_OperationType_EXCEPT = 2,
  ASTSetOperationEnums_OperationType_INTERSECT = 4,
};

bool ASTSetOperationEnums_OperationType_IsValid(int value);
extern const uint32_t ASTSetOperationEnums_OperationType_internal_data_[];
constexpr ASTSetOperationEnums_OperationType ASTSetOperationEnums_OperationType_OperationType_MIN = static_cast<ASTSetOperationEnums_OperationType>(0);
constexpr ASTSetOperationEnums_OperationType ASTSetOperationEnums_OperationType_OperationType_MAX = static_cast<ASTSetOperationEnums_OperationType>(4);
constexpr int ASTSetOperationEnums_OperationType_OperationType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ASTSetOperationEnums_OperationType_descriptor();
template <typename T>
const std::string& ASTSetOperationEnums_OperationType_Name(T value) {
  static_assert(std::is_same<T, ASTSetOperationEnums_OperationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OperationType_Name().");
  return ASTSetOperationEnums_OperationType_Name(static_cast<ASTSetOperationEnums_OperationType>(value));
}
template <>
inline const std::string& ASTSetOperationEnums_OperationType_Name(ASTSetOperationEnums_OperationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTSetOperationEnums_OperationType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ASTSetOperationEnums_OperationType_Parse(absl::string_view name, ASTSetOperationEnums_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTSetOperationEnums_OperationType>(
      ASTSetOperationEnums_OperationType_descriptor(), name, value);
}
enum ASTSetOperationEnums_AllOrDistinct : int {
  ASTSetOperationEnums_AllOrDistinct_ALL_OR_DISTINCT_NOT_SET = 0,
  ASTSetOperationEnums_AllOrDistinct_ALL = 1,
  ASTSetOperationEnums_AllOrDistinct_DISTINCT = 2,
};

bool ASTSetOperationEnums_AllOrDistinct_IsValid(int value);
extern const uint32_t ASTSetOperationEnums_AllOrDistinct_internal_data_[];
constexpr ASTSetOperationEnums_AllOrDistinct ASTSetOperationEnums_AllOrDistinct_AllOrDistinct_MIN = static_cast<ASTSetOperationEnums_AllOrDistinct>(0);
constexpr ASTSetOperationEnums_AllOrDistinct ASTSetOperationEnums_AllOrDistinct_AllOrDistinct_MAX = static_cast<ASTSetOperationEnums_AllOrDistinct>(2);
constexpr int ASTSetOperationEnums_AllOrDistinct_AllOrDistinct_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTSetOperationEnums_AllOrDistinct_descriptor();
template <typename T>
const std::string& ASTSetOperationEnums_AllOrDistinct_Name(T value) {
  static_assert(std::is_same<T, ASTSetOperationEnums_AllOrDistinct>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AllOrDistinct_Name().");
  return ASTSetOperationEnums_AllOrDistinct_Name(static_cast<ASTSetOperationEnums_AllOrDistinct>(value));
}
template <>
inline const std::string& ASTSetOperationEnums_AllOrDistinct_Name(ASTSetOperationEnums_AllOrDistinct value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTSetOperationEnums_AllOrDistinct_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTSetOperationEnums_AllOrDistinct_Parse(absl::string_view name, ASTSetOperationEnums_AllOrDistinct* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTSetOperationEnums_AllOrDistinct>(
      ASTSetOperationEnums_AllOrDistinct_descriptor(), name, value);
}
enum ASTSetOperationEnums_ColumnMatchMode : int {
  ASTSetOperationEnums_ColumnMatchMode_BY_POSITION = 1,
  ASTSetOperationEnums_ColumnMatchMode_CORRESPONDING = 2,
  ASTSetOperationEnums_ColumnMatchMode_CORRESPONDING_BY = 3,
  ASTSetOperationEnums_ColumnMatchMode_BY_NAME = 4,
  ASTSetOperationEnums_ColumnMatchMode_BY_NAME_ON = 5,
};

bool ASTSetOperationEnums_ColumnMatchMode_IsValid(int value);
extern const uint32_t ASTSetOperationEnums_ColumnMatchMode_internal_data_[];
constexpr ASTSetOperationEnums_ColumnMatchMode ASTSetOperationEnums_ColumnMatchMode_ColumnMatchMode_MIN = static_cast<ASTSetOperationEnums_ColumnMatchMode>(1);
constexpr ASTSetOperationEnums_ColumnMatchMode ASTSetOperationEnums_ColumnMatchMode_ColumnMatchMode_MAX = static_cast<ASTSetOperationEnums_ColumnMatchMode>(5);
constexpr int ASTSetOperationEnums_ColumnMatchMode_ColumnMatchMode_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ASTSetOperationEnums_ColumnMatchMode_descriptor();
template <typename T>
const std::string& ASTSetOperationEnums_ColumnMatchMode_Name(T value) {
  static_assert(std::is_same<T, ASTSetOperationEnums_ColumnMatchMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ColumnMatchMode_Name().");
  return ASTSetOperationEnums_ColumnMatchMode_Name(static_cast<ASTSetOperationEnums_ColumnMatchMode>(value));
}
template <>
inline const std::string& ASTSetOperationEnums_ColumnMatchMode_Name(ASTSetOperationEnums_ColumnMatchMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTSetOperationEnums_ColumnMatchMode_descriptor,
                                                 1, 5>(
      static_cast<int>(value));
}
inline bool ASTSetOperationEnums_ColumnMatchMode_Parse(absl::string_view name, ASTSetOperationEnums_ColumnMatchMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTSetOperationEnums_ColumnMatchMode>(
      ASTSetOperationEnums_ColumnMatchMode_descriptor(), name, value);
}
enum ASTSetOperationEnums_ColumnPropagationMode : int {
  ASTSetOperationEnums_ColumnPropagationMode_STRICT = 1,
  ASTSetOperationEnums_ColumnPropagationMode_INNER = 2,
  ASTSetOperationEnums_ColumnPropagationMode_LEFT = 3,
  ASTSetOperationEnums_ColumnPropagationMode_FULL = 4,
};

bool ASTSetOperationEnums_ColumnPropagationMode_IsValid(int value);
extern const uint32_t ASTSetOperationEnums_ColumnPropagationMode_internal_data_[];
constexpr ASTSetOperationEnums_ColumnPropagationMode ASTSetOperationEnums_ColumnPropagationMode_ColumnPropagationMode_MIN = static_cast<ASTSetOperationEnums_ColumnPropagationMode>(1);
constexpr ASTSetOperationEnums_ColumnPropagationMode ASTSetOperationEnums_ColumnPropagationMode_ColumnPropagationMode_MAX = static_cast<ASTSetOperationEnums_ColumnPropagationMode>(4);
constexpr int ASTSetOperationEnums_ColumnPropagationMode_ColumnPropagationMode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ASTSetOperationEnums_ColumnPropagationMode_descriptor();
template <typename T>
const std::string& ASTSetOperationEnums_ColumnPropagationMode_Name(T value) {
  static_assert(std::is_same<T, ASTSetOperationEnums_ColumnPropagationMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ColumnPropagationMode_Name().");
  return ASTSetOperationEnums_ColumnPropagationMode_Name(static_cast<ASTSetOperationEnums_ColumnPropagationMode>(value));
}
template <>
inline const std::string& ASTSetOperationEnums_ColumnPropagationMode_Name(ASTSetOperationEnums_ColumnPropagationMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTSetOperationEnums_ColumnPropagationMode_descriptor,
                                                 1, 4>(
      static_cast<int>(value));
}
inline bool ASTSetOperationEnums_ColumnPropagationMode_Parse(absl::string_view name, ASTSetOperationEnums_ColumnPropagationMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTSetOperationEnums_ColumnPropagationMode>(
      ASTSetOperationEnums_ColumnPropagationMode_descriptor(), name, value);
}
enum ASTUnaryExpressionEnums_Op : int {
  ASTUnaryExpressionEnums_Op_NOT_SET = 0,
  ASTUnaryExpressionEnums_Op_NOT = 1,
  ASTUnaryExpressionEnums_Op_BITWISE_NOT = 2,
  ASTUnaryExpressionEnums_Op_MINUS = 3,
  ASTUnaryExpressionEnums_Op_PLUS = 4,
  ASTUnaryExpressionEnums_Op_IS_UNKNOWN = 5,
  ASTUnaryExpressionEnums_Op_IS_NOT_UNKNOWN = 6,
};

bool ASTUnaryExpressionEnums_Op_IsValid(int value);
extern const uint32_t ASTUnaryExpressionEnums_Op_internal_data_[];
constexpr ASTUnaryExpressionEnums_Op ASTUnaryExpressionEnums_Op_Op_MIN = static_cast<ASTUnaryExpressionEnums_Op>(0);
constexpr ASTUnaryExpressionEnums_Op ASTUnaryExpressionEnums_Op_Op_MAX = static_cast<ASTUnaryExpressionEnums_Op>(6);
constexpr int ASTUnaryExpressionEnums_Op_Op_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ASTUnaryExpressionEnums_Op_descriptor();
template <typename T>
const std::string& ASTUnaryExpressionEnums_Op_Name(T value) {
  static_assert(std::is_same<T, ASTUnaryExpressionEnums_Op>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Op_Name().");
  return ASTUnaryExpressionEnums_Op_Name(static_cast<ASTUnaryExpressionEnums_Op>(value));
}
template <>
inline const std::string& ASTUnaryExpressionEnums_Op_Name(ASTUnaryExpressionEnums_Op value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTUnaryExpressionEnums_Op_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ASTUnaryExpressionEnums_Op_Parse(absl::string_view name, ASTUnaryExpressionEnums_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTUnaryExpressionEnums_Op>(
      ASTUnaryExpressionEnums_Op_descriptor(), name, value);
}
enum ASTWindowFrameEnums_FrameUnit : int {
  ASTWindowFrameEnums_FrameUnit_ROWS = 1,
  ASTWindowFrameEnums_FrameUnit_RANGE = 2,
};

bool ASTWindowFrameEnums_FrameUnit_IsValid(int value);
extern const uint32_t ASTWindowFrameEnums_FrameUnit_internal_data_[];
constexpr ASTWindowFrameEnums_FrameUnit ASTWindowFrameEnums_FrameUnit_FrameUnit_MIN = static_cast<ASTWindowFrameEnums_FrameUnit>(1);
constexpr ASTWindowFrameEnums_FrameUnit ASTWindowFrameEnums_FrameUnit_FrameUnit_MAX = static_cast<ASTWindowFrameEnums_FrameUnit>(2);
constexpr int ASTWindowFrameEnums_FrameUnit_FrameUnit_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTWindowFrameEnums_FrameUnit_descriptor();
template <typename T>
const std::string& ASTWindowFrameEnums_FrameUnit_Name(T value) {
  static_assert(std::is_same<T, ASTWindowFrameEnums_FrameUnit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FrameUnit_Name().");
  return ASTWindowFrameEnums_FrameUnit_Name(static_cast<ASTWindowFrameEnums_FrameUnit>(value));
}
template <>
inline const std::string& ASTWindowFrameEnums_FrameUnit_Name(ASTWindowFrameEnums_FrameUnit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTWindowFrameEnums_FrameUnit_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool ASTWindowFrameEnums_FrameUnit_Parse(absl::string_view name, ASTWindowFrameEnums_FrameUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTWindowFrameEnums_FrameUnit>(
      ASTWindowFrameEnums_FrameUnit_descriptor(), name, value);
}
enum ASTWindowFrameExprEnums_BoundaryType : int {
  ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING = 1,
  ASTWindowFrameExprEnums_BoundaryType_OFFSET_PRECEDING = 2,
  ASTWindowFrameExprEnums_BoundaryType_CURRENT_ROW = 3,
  ASTWindowFrameExprEnums_BoundaryType_OFFSET_FOLLOWING = 4,
  ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING = 5,
};

bool ASTWindowFrameExprEnums_BoundaryType_IsValid(int value);
extern const uint32_t ASTWindowFrameExprEnums_BoundaryType_internal_data_[];
constexpr ASTWindowFrameExprEnums_BoundaryType ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MIN = static_cast<ASTWindowFrameExprEnums_BoundaryType>(1);
constexpr ASTWindowFrameExprEnums_BoundaryType ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MAX = static_cast<ASTWindowFrameExprEnums_BoundaryType>(5);
constexpr int ASTWindowFrameExprEnums_BoundaryType_BoundaryType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ASTWindowFrameExprEnums_BoundaryType_descriptor();
template <typename T>
const std::string& ASTWindowFrameExprEnums_BoundaryType_Name(T value) {
  static_assert(std::is_same<T, ASTWindowFrameExprEnums_BoundaryType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BoundaryType_Name().");
  return ASTWindowFrameExprEnums_BoundaryType_Name(static_cast<ASTWindowFrameExprEnums_BoundaryType>(value));
}
template <>
inline const std::string& ASTWindowFrameExprEnums_BoundaryType_Name(ASTWindowFrameExprEnums_BoundaryType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTWindowFrameExprEnums_BoundaryType_descriptor,
                                                 1, 5>(
      static_cast<int>(value));
}
inline bool ASTWindowFrameExprEnums_BoundaryType_Parse(absl::string_view name, ASTWindowFrameExprEnums_BoundaryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTWindowFrameExprEnums_BoundaryType>(
      ASTWindowFrameExprEnums_BoundaryType_descriptor(), name, value);
}
enum ASTAnySomeAllOpEnums_Op : int {
  ASTAnySomeAllOpEnums_Op_kUninitialized = 1,
  ASTAnySomeAllOpEnums_Op_kAny = 2,
  ASTAnySomeAllOpEnums_Op_kSome = 3,
  ASTAnySomeAllOpEnums_Op_kAll = 4,
};

bool ASTAnySomeAllOpEnums_Op_IsValid(int value);
extern const uint32_t ASTAnySomeAllOpEnums_Op_internal_data_[];
constexpr ASTAnySomeAllOpEnums_Op ASTAnySomeAllOpEnums_Op_Op_MIN = static_cast<ASTAnySomeAllOpEnums_Op>(1);
constexpr ASTAnySomeAllOpEnums_Op ASTAnySomeAllOpEnums_Op_Op_MAX = static_cast<ASTAnySomeAllOpEnums_Op>(4);
constexpr int ASTAnySomeAllOpEnums_Op_Op_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ASTAnySomeAllOpEnums_Op_descriptor();
template <typename T>
const std::string& ASTAnySomeAllOpEnums_Op_Name(T value) {
  static_assert(std::is_same<T, ASTAnySomeAllOpEnums_Op>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Op_Name().");
  return ASTAnySomeAllOpEnums_Op_Name(static_cast<ASTAnySomeAllOpEnums_Op>(value));
}
template <>
inline const std::string& ASTAnySomeAllOpEnums_Op_Name(ASTAnySomeAllOpEnums_Op value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTAnySomeAllOpEnums_Op_descriptor,
                                                 1, 4>(
      static_cast<int>(value));
}
inline bool ASTAnySomeAllOpEnums_Op_Parse(absl::string_view name, ASTAnySomeAllOpEnums_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTAnySomeAllOpEnums_Op>(
      ASTAnySomeAllOpEnums_Op_descriptor(), name, value);
}
enum ASTTransactionReadWriteModeEnums_Mode : int {
  ASTTransactionReadWriteModeEnums_Mode_INVALID = 0,
  ASTTransactionReadWriteModeEnums_Mode_READ_ONLY = 1,
  ASTTransactionReadWriteModeEnums_Mode_READ_WRITE = 2,
};

bool ASTTransactionReadWriteModeEnums_Mode_IsValid(int value);
extern const uint32_t ASTTransactionReadWriteModeEnums_Mode_internal_data_[];
constexpr ASTTransactionReadWriteModeEnums_Mode ASTTransactionReadWriteModeEnums_Mode_Mode_MIN = static_cast<ASTTransactionReadWriteModeEnums_Mode>(0);
constexpr ASTTransactionReadWriteModeEnums_Mode ASTTransactionReadWriteModeEnums_Mode_Mode_MAX = static_cast<ASTTransactionReadWriteModeEnums_Mode>(2);
constexpr int ASTTransactionReadWriteModeEnums_Mode_Mode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTTransactionReadWriteModeEnums_Mode_descriptor();
template <typename T>
const std::string& ASTTransactionReadWriteModeEnums_Mode_Name(T value) {
  static_assert(std::is_same<T, ASTTransactionReadWriteModeEnums_Mode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Mode_Name().");
  return ASTTransactionReadWriteModeEnums_Mode_Name(static_cast<ASTTransactionReadWriteModeEnums_Mode>(value));
}
template <>
inline const std::string& ASTTransactionReadWriteModeEnums_Mode_Name(ASTTransactionReadWriteModeEnums_Mode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTTransactionReadWriteModeEnums_Mode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTTransactionReadWriteModeEnums_Mode_Parse(absl::string_view name, ASTTransactionReadWriteModeEnums_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTTransactionReadWriteModeEnums_Mode>(
      ASTTransactionReadWriteModeEnums_Mode_descriptor(), name, value);
}
enum ASTImportStatementEnums_ImportKind : int {
  ASTImportStatementEnums_ImportKind_MODULE = 1,
  ASTImportStatementEnums_ImportKind_PROTO = 2,
};

bool ASTImportStatementEnums_ImportKind_IsValid(int value);
extern const uint32_t ASTImportStatementEnums_ImportKind_internal_data_[];
constexpr ASTImportStatementEnums_ImportKind ASTImportStatementEnums_ImportKind_ImportKind_MIN = static_cast<ASTImportStatementEnums_ImportKind>(1);
constexpr ASTImportStatementEnums_ImportKind ASTImportStatementEnums_ImportKind_ImportKind_MAX = static_cast<ASTImportStatementEnums_ImportKind>(2);
constexpr int ASTImportStatementEnums_ImportKind_ImportKind_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTImportStatementEnums_ImportKind_descriptor();
template <typename T>
const std::string& ASTImportStatementEnums_ImportKind_Name(T value) {
  static_assert(std::is_same<T, ASTImportStatementEnums_ImportKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ImportKind_Name().");
  return ASTImportStatementEnums_ImportKind_Name(static_cast<ASTImportStatementEnums_ImportKind>(value));
}
template <>
inline const std::string& ASTImportStatementEnums_ImportKind_Name(ASTImportStatementEnums_ImportKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTImportStatementEnums_ImportKind_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool ASTImportStatementEnums_ImportKind_Parse(absl::string_view name, ASTImportStatementEnums_ImportKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTImportStatementEnums_ImportKind>(
      ASTImportStatementEnums_ImportKind_descriptor(), name, value);
}
enum ASTUnpivotClauseEnums_NullFilter : int {
  ASTUnpivotClauseEnums_NullFilter_kUnspecified = 1,
  ASTUnpivotClauseEnums_NullFilter_kInclude = 2,
  ASTUnpivotClauseEnums_NullFilter_kExclude = 3,
};

bool ASTUnpivotClauseEnums_NullFilter_IsValid(int value);
extern const uint32_t ASTUnpivotClauseEnums_NullFilter_internal_data_[];
constexpr ASTUnpivotClauseEnums_NullFilter ASTUnpivotClauseEnums_NullFilter_NullFilter_MIN = static_cast<ASTUnpivotClauseEnums_NullFilter>(1);
constexpr ASTUnpivotClauseEnums_NullFilter ASTUnpivotClauseEnums_NullFilter_NullFilter_MAX = static_cast<ASTUnpivotClauseEnums_NullFilter>(3);
constexpr int ASTUnpivotClauseEnums_NullFilter_NullFilter_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTUnpivotClauseEnums_NullFilter_descriptor();
template <typename T>
const std::string& ASTUnpivotClauseEnums_NullFilter_Name(T value) {
  static_assert(std::is_same<T, ASTUnpivotClauseEnums_NullFilter>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NullFilter_Name().");
  return ASTUnpivotClauseEnums_NullFilter_Name(static_cast<ASTUnpivotClauseEnums_NullFilter>(value));
}
template <>
inline const std::string& ASTUnpivotClauseEnums_NullFilter_Name(ASTUnpivotClauseEnums_NullFilter value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTUnpivotClauseEnums_NullFilter_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool ASTUnpivotClauseEnums_NullFilter_Parse(absl::string_view name, ASTUnpivotClauseEnums_NullFilter* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTUnpivotClauseEnums_NullFilter>(
      ASTUnpivotClauseEnums_NullFilter_descriptor(), name, value);
}
enum ASTCreateStatementEnums_Scope : int {
  ASTCreateStatementEnums_Scope_DEFAULT_SCOPE = 0,
  ASTCreateStatementEnums_Scope_PRIVATE = 1,
  ASTCreateStatementEnums_Scope_PUBLIC = 2,
  ASTCreateStatementEnums_Scope_TEMPORARY = 3,
};

bool ASTCreateStatementEnums_Scope_IsValid(int value);
extern const uint32_t ASTCreateStatementEnums_Scope_internal_data_[];
constexpr ASTCreateStatementEnums_Scope ASTCreateStatementEnums_Scope_Scope_MIN = static_cast<ASTCreateStatementEnums_Scope>(0);
constexpr ASTCreateStatementEnums_Scope ASTCreateStatementEnums_Scope_Scope_MAX = static_cast<ASTCreateStatementEnums_Scope>(3);
constexpr int ASTCreateStatementEnums_Scope_Scope_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTCreateStatementEnums_Scope_descriptor();
template <typename T>
const std::string& ASTCreateStatementEnums_Scope_Name(T value) {
  static_assert(std::is_same<T, ASTCreateStatementEnums_Scope>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Scope_Name().");
  return ASTCreateStatementEnums_Scope_Name(static_cast<ASTCreateStatementEnums_Scope>(value));
}
template <>
inline const std::string& ASTCreateStatementEnums_Scope_Name(ASTCreateStatementEnums_Scope value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTCreateStatementEnums_Scope_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTCreateStatementEnums_Scope_Parse(absl::string_view name, ASTCreateStatementEnums_Scope* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTCreateStatementEnums_Scope>(
      ASTCreateStatementEnums_Scope_descriptor(), name, value);
}
enum ASTCreateStatementEnums_SqlSecurity : int {
  ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED = 0,
  ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_DEFINER = 1,
  ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER = 2,
};

bool ASTCreateStatementEnums_SqlSecurity_IsValid(int value);
extern const uint32_t ASTCreateStatementEnums_SqlSecurity_internal_data_[];
constexpr ASTCreateStatementEnums_SqlSecurity ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MIN = static_cast<ASTCreateStatementEnums_SqlSecurity>(0);
constexpr ASTCreateStatementEnums_SqlSecurity ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MAX = static_cast<ASTCreateStatementEnums_SqlSecurity>(2);
constexpr int ASTCreateStatementEnums_SqlSecurity_SqlSecurity_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTCreateStatementEnums_SqlSecurity_descriptor();
template <typename T>
const std::string& ASTCreateStatementEnums_SqlSecurity_Name(T value) {
  static_assert(std::is_same<T, ASTCreateStatementEnums_SqlSecurity>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSecurity_Name().");
  return ASTCreateStatementEnums_SqlSecurity_Name(static_cast<ASTCreateStatementEnums_SqlSecurity>(value));
}
template <>
inline const std::string& ASTCreateStatementEnums_SqlSecurity_Name(ASTCreateStatementEnums_SqlSecurity value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTCreateStatementEnums_SqlSecurity_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTCreateStatementEnums_SqlSecurity_Parse(absl::string_view name, ASTCreateStatementEnums_SqlSecurity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTCreateStatementEnums_SqlSecurity>(
      ASTCreateStatementEnums_SqlSecurity_descriptor(), name, value);
}
enum ASTFunctionParameterEnums_ProcedureParameterMode : int {
  ASTFunctionParameterEnums_ProcedureParameterMode_NOT_SET = 0,
  ASTFunctionParameterEnums_ProcedureParameterMode_IN = 1,
  ASTFunctionParameterEnums_ProcedureParameterMode_OUT = 2,
  ASTFunctionParameterEnums_ProcedureParameterMode_INOUT = 3,
};

bool ASTFunctionParameterEnums_ProcedureParameterMode_IsValid(int value);
extern const uint32_t ASTFunctionParameterEnums_ProcedureParameterMode_internal_data_[];
constexpr ASTFunctionParameterEnums_ProcedureParameterMode ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MIN = static_cast<ASTFunctionParameterEnums_ProcedureParameterMode>(0);
constexpr ASTFunctionParameterEnums_ProcedureParameterMode ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MAX = static_cast<ASTFunctionParameterEnums_ProcedureParameterMode>(3);
constexpr int ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTFunctionParameterEnums_ProcedureParameterMode_descriptor();
template <typename T>
const std::string& ASTFunctionParameterEnums_ProcedureParameterMode_Name(T value) {
  static_assert(std::is_same<T, ASTFunctionParameterEnums_ProcedureParameterMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProcedureParameterMode_Name().");
  return ASTFunctionParameterEnums_ProcedureParameterMode_Name(static_cast<ASTFunctionParameterEnums_ProcedureParameterMode>(value));
}
template <>
inline const std::string& ASTFunctionParameterEnums_ProcedureParameterMode_Name(ASTFunctionParameterEnums_ProcedureParameterMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTFunctionParameterEnums_ProcedureParameterMode_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTFunctionParameterEnums_ProcedureParameterMode_Parse(absl::string_view name, ASTFunctionParameterEnums_ProcedureParameterMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTFunctionParameterEnums_ProcedureParameterMode>(
      ASTFunctionParameterEnums_ProcedureParameterMode_descriptor(), name, value);
}
enum ASTTemplatedParameterTypeEnums_TemplatedTypeKind : int {
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_UNINITIALIZED = 1,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TYPE = 2,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_PROTO = 3,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ENUM = 4,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_STRUCT = 5,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ARRAY = 6,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TABLE = 7,
};

bool ASTTemplatedParameterTypeEnums_TemplatedTypeKind_IsValid(int value);
extern const uint32_t ASTTemplatedParameterTypeEnums_TemplatedTypeKind_internal_data_[];
constexpr ASTTemplatedParameterTypeEnums_TemplatedTypeKind ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MIN = static_cast<ASTTemplatedParameterTypeEnums_TemplatedTypeKind>(1);
constexpr ASTTemplatedParameterTypeEnums_TemplatedTypeKind ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MAX = static_cast<ASTTemplatedParameterTypeEnums_TemplatedTypeKind>(7);
constexpr int ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor();
template <typename T>
const std::string& ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Name(T value) {
  static_assert(std::is_same<T, ASTTemplatedParameterTypeEnums_TemplatedTypeKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TemplatedTypeKind_Name().");
  return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Name(static_cast<ASTTemplatedParameterTypeEnums_TemplatedTypeKind>(value));
}
template <>
inline const std::string& ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Name(ASTTemplatedParameterTypeEnums_TemplatedTypeKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor,
                                                 1, 7>(
      static_cast<int>(value));
}
inline bool ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Parse(absl::string_view name, ASTTemplatedParameterTypeEnums_TemplatedTypeKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTTemplatedParameterTypeEnums_TemplatedTypeKind>(
      ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor(), name, value);
}
enum ASTGeneratedColumnInfoEnums_StoredMode : int {
  ASTGeneratedColumnInfoEnums_StoredMode_NON_STORED = 0,
  ASTGeneratedColumnInfoEnums_StoredMode_STORED = 1,
  ASTGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE = 2,
};

bool ASTGeneratedColumnInfoEnums_StoredMode_IsValid(int value);
extern const uint32_t ASTGeneratedColumnInfoEnums_StoredMode_internal_data_[];
constexpr ASTGeneratedColumnInfoEnums_StoredMode ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MIN = static_cast<ASTGeneratedColumnInfoEnums_StoredMode>(0);
constexpr ASTGeneratedColumnInfoEnums_StoredMode ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX = static_cast<ASTGeneratedColumnInfoEnums_StoredMode>(2);
constexpr int ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTGeneratedColumnInfoEnums_StoredMode_descriptor();
template <typename T>
const std::string& ASTGeneratedColumnInfoEnums_StoredMode_Name(T value) {
  static_assert(std::is_same<T, ASTGeneratedColumnInfoEnums_StoredMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StoredMode_Name().");
  return ASTGeneratedColumnInfoEnums_StoredMode_Name(static_cast<ASTGeneratedColumnInfoEnums_StoredMode>(value));
}
template <>
inline const std::string& ASTGeneratedColumnInfoEnums_StoredMode_Name(ASTGeneratedColumnInfoEnums_StoredMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTGeneratedColumnInfoEnums_StoredMode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTGeneratedColumnInfoEnums_StoredMode_Parse(absl::string_view name, ASTGeneratedColumnInfoEnums_StoredMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTGeneratedColumnInfoEnums_StoredMode>(
      ASTGeneratedColumnInfoEnums_StoredMode_descriptor(), name, value);
}
enum ASTGeneratedColumnInfoEnums_GeneratedMode : int {
  ASTGeneratedColumnInfoEnums_GeneratedMode_ALWAYS = 0,
  ASTGeneratedColumnInfoEnums_GeneratedMode_BY_DEFAULT = 1,
};

bool ASTGeneratedColumnInfoEnums_GeneratedMode_IsValid(int value);
extern const uint32_t ASTGeneratedColumnInfoEnums_GeneratedMode_internal_data_[];
constexpr ASTGeneratedColumnInfoEnums_GeneratedMode ASTGeneratedColumnInfoEnums_GeneratedMode_GeneratedMode_MIN = static_cast<ASTGeneratedColumnInfoEnums_GeneratedMode>(0);
constexpr ASTGeneratedColumnInfoEnums_GeneratedMode ASTGeneratedColumnInfoEnums_GeneratedMode_GeneratedMode_MAX = static_cast<ASTGeneratedColumnInfoEnums_GeneratedMode>(1);
constexpr int ASTGeneratedColumnInfoEnums_GeneratedMode_GeneratedMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ASTGeneratedColumnInfoEnums_GeneratedMode_descriptor();
template <typename T>
const std::string& ASTGeneratedColumnInfoEnums_GeneratedMode_Name(T value) {
  static_assert(std::is_same<T, ASTGeneratedColumnInfoEnums_GeneratedMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GeneratedMode_Name().");
  return ASTGeneratedColumnInfoEnums_GeneratedMode_Name(static_cast<ASTGeneratedColumnInfoEnums_GeneratedMode>(value));
}
template <>
inline const std::string& ASTGeneratedColumnInfoEnums_GeneratedMode_Name(ASTGeneratedColumnInfoEnums_GeneratedMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTGeneratedColumnInfoEnums_GeneratedMode_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ASTGeneratedColumnInfoEnums_GeneratedMode_Parse(absl::string_view name, ASTGeneratedColumnInfoEnums_GeneratedMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTGeneratedColumnInfoEnums_GeneratedMode>(
      ASTGeneratedColumnInfoEnums_GeneratedMode_descriptor(), name, value);
}
enum ASTColumnPositionEnums_RelativePositionType : int {
  ASTColumnPositionEnums_RelativePositionType_PRECEDING = 1,
  ASTColumnPositionEnums_RelativePositionType_FOLLOWING = 2,
};

bool ASTColumnPositionEnums_RelativePositionType_IsValid(int value);
extern const uint32_t ASTColumnPositionEnums_RelativePositionType_internal_data_[];
constexpr ASTColumnPositionEnums_RelativePositionType ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MIN = static_cast<ASTColumnPositionEnums_RelativePositionType>(1);
constexpr ASTColumnPositionEnums_RelativePositionType ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MAX = static_cast<ASTColumnPositionEnums_RelativePositionType>(2);
constexpr int ASTColumnPositionEnums_RelativePositionType_RelativePositionType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTColumnPositionEnums_RelativePositionType_descriptor();
template <typename T>
const std::string& ASTColumnPositionEnums_RelativePositionType_Name(T value) {
  static_assert(std::is_same<T, ASTColumnPositionEnums_RelativePositionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RelativePositionType_Name().");
  return ASTColumnPositionEnums_RelativePositionType_Name(static_cast<ASTColumnPositionEnums_RelativePositionType>(value));
}
template <>
inline const std::string& ASTColumnPositionEnums_RelativePositionType_Name(ASTColumnPositionEnums_RelativePositionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTColumnPositionEnums_RelativePositionType_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool ASTColumnPositionEnums_RelativePositionType_Parse(absl::string_view name, ASTColumnPositionEnums_RelativePositionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTColumnPositionEnums_RelativePositionType>(
      ASTColumnPositionEnums_RelativePositionType_descriptor(), name, value);
}
enum ASTInsertStatementEnums_InsertMode : int {
  ASTInsertStatementEnums_InsertMode_DEFAULT_MODE = 0,
  ASTInsertStatementEnums_InsertMode_REPLACE = 1,
  ASTInsertStatementEnums_InsertMode_UPDATE = 2,
  ASTInsertStatementEnums_InsertMode_IGNORE = 3,
};

bool ASTInsertStatementEnums_InsertMode_IsValid(int value);
extern const uint32_t ASTInsertStatementEnums_InsertMode_internal_data_[];
constexpr ASTInsertStatementEnums_InsertMode ASTInsertStatementEnums_InsertMode_InsertMode_MIN = static_cast<ASTInsertStatementEnums_InsertMode>(0);
constexpr ASTInsertStatementEnums_InsertMode ASTInsertStatementEnums_InsertMode_InsertMode_MAX = static_cast<ASTInsertStatementEnums_InsertMode>(3);
constexpr int ASTInsertStatementEnums_InsertMode_InsertMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTInsertStatementEnums_InsertMode_descriptor();
template <typename T>
const std::string& ASTInsertStatementEnums_InsertMode_Name(T value) {
  static_assert(std::is_same<T, ASTInsertStatementEnums_InsertMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InsertMode_Name().");
  return ASTInsertStatementEnums_InsertMode_Name(static_cast<ASTInsertStatementEnums_InsertMode>(value));
}
template <>
inline const std::string& ASTInsertStatementEnums_InsertMode_Name(ASTInsertStatementEnums_InsertMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTInsertStatementEnums_InsertMode_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTInsertStatementEnums_InsertMode_Parse(absl::string_view name, ASTInsertStatementEnums_InsertMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTInsertStatementEnums_InsertMode>(
      ASTInsertStatementEnums_InsertMode_descriptor(), name, value);
}
enum ASTInsertStatementEnums_ParseProgress : int {
  ASTInsertStatementEnums_ParseProgress_kInitial = 1,
  ASTInsertStatementEnums_ParseProgress_kSeenOrIgnoreReplaceUpdate = 2,
  ASTInsertStatementEnums_ParseProgress_kSeenTargetPath = 3,
  ASTInsertStatementEnums_ParseProgress_kSeenColumnList = 4,
  ASTInsertStatementEnums_ParseProgress_kSeenValuesList = 5,
};

bool ASTInsertStatementEnums_ParseProgress_IsValid(int value);
extern const uint32_t ASTInsertStatementEnums_ParseProgress_internal_data_[];
constexpr ASTInsertStatementEnums_ParseProgress ASTInsertStatementEnums_ParseProgress_ParseProgress_MIN = static_cast<ASTInsertStatementEnums_ParseProgress>(1);
constexpr ASTInsertStatementEnums_ParseProgress ASTInsertStatementEnums_ParseProgress_ParseProgress_MAX = static_cast<ASTInsertStatementEnums_ParseProgress>(5);
constexpr int ASTInsertStatementEnums_ParseProgress_ParseProgress_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ASTInsertStatementEnums_ParseProgress_descriptor();
template <typename T>
const std::string& ASTInsertStatementEnums_ParseProgress_Name(T value) {
  static_assert(std::is_same<T, ASTInsertStatementEnums_ParseProgress>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ParseProgress_Name().");
  return ASTInsertStatementEnums_ParseProgress_Name(static_cast<ASTInsertStatementEnums_ParseProgress>(value));
}
template <>
inline const std::string& ASTInsertStatementEnums_ParseProgress_Name(ASTInsertStatementEnums_ParseProgress value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTInsertStatementEnums_ParseProgress_descriptor,
                                                 1, 5>(
      static_cast<int>(value));
}
inline bool ASTInsertStatementEnums_ParseProgress_Parse(absl::string_view name, ASTInsertStatementEnums_ParseProgress* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTInsertStatementEnums_ParseProgress>(
      ASTInsertStatementEnums_ParseProgress_descriptor(), name, value);
}
enum ASTOnConflictClauseEnums_ConflictAction : int {
  ASTOnConflictClauseEnums_ConflictAction_NOT_SET = 0,
  ASTOnConflictClauseEnums_ConflictAction_NOTHING = 1,
  ASTOnConflictClauseEnums_ConflictAction_UPDATE = 2,
};

bool ASTOnConflictClauseEnums_ConflictAction_IsValid(int value);
extern const uint32_t ASTOnConflictClauseEnums_ConflictAction_internal_data_[];
constexpr ASTOnConflictClauseEnums_ConflictAction ASTOnConflictClauseEnums_ConflictAction_ConflictAction_MIN = static_cast<ASTOnConflictClauseEnums_ConflictAction>(0);
constexpr ASTOnConflictClauseEnums_ConflictAction ASTOnConflictClauseEnums_ConflictAction_ConflictAction_MAX = static_cast<ASTOnConflictClauseEnums_ConflictAction>(2);
constexpr int ASTOnConflictClauseEnums_ConflictAction_ConflictAction_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTOnConflictClauseEnums_ConflictAction_descriptor();
template <typename T>
const std::string& ASTOnConflictClauseEnums_ConflictAction_Name(T value) {
  static_assert(std::is_same<T, ASTOnConflictClauseEnums_ConflictAction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ConflictAction_Name().");
  return ASTOnConflictClauseEnums_ConflictAction_Name(static_cast<ASTOnConflictClauseEnums_ConflictAction>(value));
}
template <>
inline const std::string& ASTOnConflictClauseEnums_ConflictAction_Name(ASTOnConflictClauseEnums_ConflictAction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTOnConflictClauseEnums_ConflictAction_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTOnConflictClauseEnums_ConflictAction_Parse(absl::string_view name, ASTOnConflictClauseEnums_ConflictAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTOnConflictClauseEnums_ConflictAction>(
      ASTOnConflictClauseEnums_ConflictAction_descriptor(), name, value);
}
enum ASTMergeActionEnums_ActionType : int {
  ASTMergeActionEnums_ActionType_NOT_SET = 0,
  ASTMergeActionEnums_ActionType_INSERT = 1,
  ASTMergeActionEnums_ActionType_UPDATE = 2,
  ASTMergeActionEnums_ActionType_DELETE = 3,
};

bool ASTMergeActionEnums_ActionType_IsValid(int value);
extern const uint32_t ASTMergeActionEnums_ActionType_internal_data_[];
constexpr ASTMergeActionEnums_ActionType ASTMergeActionEnums_ActionType_ActionType_MIN = static_cast<ASTMergeActionEnums_ActionType>(0);
constexpr ASTMergeActionEnums_ActionType ASTMergeActionEnums_ActionType_ActionType_MAX = static_cast<ASTMergeActionEnums_ActionType>(3);
constexpr int ASTMergeActionEnums_ActionType_ActionType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTMergeActionEnums_ActionType_descriptor();
template <typename T>
const std::string& ASTMergeActionEnums_ActionType_Name(T value) {
  static_assert(std::is_same<T, ASTMergeActionEnums_ActionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ActionType_Name().");
  return ASTMergeActionEnums_ActionType_Name(static_cast<ASTMergeActionEnums_ActionType>(value));
}
template <>
inline const std::string& ASTMergeActionEnums_ActionType_Name(ASTMergeActionEnums_ActionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTMergeActionEnums_ActionType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTMergeActionEnums_ActionType_Parse(absl::string_view name, ASTMergeActionEnums_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTMergeActionEnums_ActionType>(
      ASTMergeActionEnums_ActionType_descriptor(), name, value);
}
enum ASTMergeWhenClauseEnums_MatchType : int {
  ASTMergeWhenClauseEnums_MatchType_NOT_SET = 0,
  ASTMergeWhenClauseEnums_MatchType_MATCHED = 1,
  ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_SOURCE = 2,
  ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_TARGET = 3,
};

bool ASTMergeWhenClauseEnums_MatchType_IsValid(int value);
extern const uint32_t ASTMergeWhenClauseEnums_MatchType_internal_data_[];
constexpr ASTMergeWhenClauseEnums_MatchType ASTMergeWhenClauseEnums_MatchType_MatchType_MIN = static_cast<ASTMergeWhenClauseEnums_MatchType>(0);
constexpr ASTMergeWhenClauseEnums_MatchType ASTMergeWhenClauseEnums_MatchType_MatchType_MAX = static_cast<ASTMergeWhenClauseEnums_MatchType>(3);
constexpr int ASTMergeWhenClauseEnums_MatchType_MatchType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTMergeWhenClauseEnums_MatchType_descriptor();
template <typename T>
const std::string& ASTMergeWhenClauseEnums_MatchType_Name(T value) {
  static_assert(std::is_same<T, ASTMergeWhenClauseEnums_MatchType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MatchType_Name().");
  return ASTMergeWhenClauseEnums_MatchType_Name(static_cast<ASTMergeWhenClauseEnums_MatchType>(value));
}
template <>
inline const std::string& ASTMergeWhenClauseEnums_MatchType_Name(ASTMergeWhenClauseEnums_MatchType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTMergeWhenClauseEnums_MatchType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTMergeWhenClauseEnums_MatchType_Parse(absl::string_view name, ASTMergeWhenClauseEnums_MatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTMergeWhenClauseEnums_MatchType>(
      ASTMergeWhenClauseEnums_MatchType_descriptor(), name, value);
}
enum ASTFilterFieldsArgEnums_FilterType : int {
  ASTFilterFieldsArgEnums_FilterType_NOT_SET = 0,
  ASTFilterFieldsArgEnums_FilterType_INCLUDE = 1,
  ASTFilterFieldsArgEnums_FilterType_EXCLUDE = 2,
};

bool ASTFilterFieldsArgEnums_FilterType_IsValid(int value);
extern const uint32_t ASTFilterFieldsArgEnums_FilterType_internal_data_[];
constexpr ASTFilterFieldsArgEnums_FilterType ASTFilterFieldsArgEnums_FilterType_FilterType_MIN = static_cast<ASTFilterFieldsArgEnums_FilterType>(0);
constexpr ASTFilterFieldsArgEnums_FilterType ASTFilterFieldsArgEnums_FilterType_FilterType_MAX = static_cast<ASTFilterFieldsArgEnums_FilterType>(2);
constexpr int ASTFilterFieldsArgEnums_FilterType_FilterType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTFilterFieldsArgEnums_FilterType_descriptor();
template <typename T>
const std::string& ASTFilterFieldsArgEnums_FilterType_Name(T value) {
  static_assert(std::is_same<T, ASTFilterFieldsArgEnums_FilterType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FilterType_Name().");
  return ASTFilterFieldsArgEnums_FilterType_Name(static_cast<ASTFilterFieldsArgEnums_FilterType>(value));
}
template <>
inline const std::string& ASTFilterFieldsArgEnums_FilterType_Name(ASTFilterFieldsArgEnums_FilterType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTFilterFieldsArgEnums_FilterType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTFilterFieldsArgEnums_FilterType_Parse(absl::string_view name, ASTFilterFieldsArgEnums_FilterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTFilterFieldsArgEnums_FilterType>(
      ASTFilterFieldsArgEnums_FilterType_descriptor(), name, value);
}
enum ASTSampleSizeEnums_Unit : int {
  ASTSampleSizeEnums_Unit_NOT_SET = 0,
  ASTSampleSizeEnums_Unit_ROWS = 1,
  ASTSampleSizeEnums_Unit_PERCENT = 2,
};

bool ASTSampleSizeEnums_Unit_IsValid(int value);
extern const uint32_t ASTSampleSizeEnums_Unit_internal_data_[];
constexpr ASTSampleSizeEnums_Unit ASTSampleSizeEnums_Unit_Unit_MIN = static_cast<ASTSampleSizeEnums_Unit>(0);
constexpr ASTSampleSizeEnums_Unit ASTSampleSizeEnums_Unit_Unit_MAX = static_cast<ASTSampleSizeEnums_Unit>(2);
constexpr int ASTSampleSizeEnums_Unit_Unit_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTSampleSizeEnums_Unit_descriptor();
template <typename T>
const std::string& ASTSampleSizeEnums_Unit_Name(T value) {
  static_assert(std::is_same<T, ASTSampleSizeEnums_Unit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Unit_Name().");
  return ASTSampleSizeEnums_Unit_Name(static_cast<ASTSampleSizeEnums_Unit>(value));
}
template <>
inline const std::string& ASTSampleSizeEnums_Unit_Name(ASTSampleSizeEnums_Unit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTSampleSizeEnums_Unit_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTSampleSizeEnums_Unit_Parse(absl::string_view name, ASTSampleSizeEnums_Unit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTSampleSizeEnums_Unit>(
      ASTSampleSizeEnums_Unit_descriptor(), name, value);
}
enum ASTForeignKeyActionsEnums_Action : int {
  ASTForeignKeyActionsEnums_Action_NO_ACTION = 0,
  ASTForeignKeyActionsEnums_Action_RESTRICT = 1,
  ASTForeignKeyActionsEnums_Action_CASCADE = 2,
  ASTForeignKeyActionsEnums_Action_SET_NULL = 3,
};

bool ASTForeignKeyActionsEnums_Action_IsValid(int value);
extern const uint32_t ASTForeignKeyActionsEnums_Action_internal_data_[];
constexpr ASTForeignKeyActionsEnums_Action ASTForeignKeyActionsEnums_Action_Action_MIN = static_cast<ASTForeignKeyActionsEnums_Action>(0);
constexpr ASTForeignKeyActionsEnums_Action ASTForeignKeyActionsEnums_Action_Action_MAX = static_cast<ASTForeignKeyActionsEnums_Action>(3);
constexpr int ASTForeignKeyActionsEnums_Action_Action_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTForeignKeyActionsEnums_Action_descriptor();
template <typename T>
const std::string& ASTForeignKeyActionsEnums_Action_Name(T value) {
  static_assert(std::is_same<T, ASTForeignKeyActionsEnums_Action>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Action_Name().");
  return ASTForeignKeyActionsEnums_Action_Name(static_cast<ASTForeignKeyActionsEnums_Action>(value));
}
template <>
inline const std::string& ASTForeignKeyActionsEnums_Action_Name(ASTForeignKeyActionsEnums_Action value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTForeignKeyActionsEnums_Action_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTForeignKeyActionsEnums_Action_Parse(absl::string_view name, ASTForeignKeyActionsEnums_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTForeignKeyActionsEnums_Action>(
      ASTForeignKeyActionsEnums_Action_descriptor(), name, value);
}
enum ASTForeignKeyReferenceEnums_Match : int {
  ASTForeignKeyReferenceEnums_Match_SIMPLE = 1,
  ASTForeignKeyReferenceEnums_Match_FULL = 2,
  ASTForeignKeyReferenceEnums_Match_NOT_DISTINCT = 3,
};

bool ASTForeignKeyReferenceEnums_Match_IsValid(int value);
extern const uint32_t ASTForeignKeyReferenceEnums_Match_internal_data_[];
constexpr ASTForeignKeyReferenceEnums_Match ASTForeignKeyReferenceEnums_Match_Match_MIN = static_cast<ASTForeignKeyReferenceEnums_Match>(1);
constexpr ASTForeignKeyReferenceEnums_Match ASTForeignKeyReferenceEnums_Match_Match_MAX = static_cast<ASTForeignKeyReferenceEnums_Match>(3);
constexpr int ASTForeignKeyReferenceEnums_Match_Match_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTForeignKeyReferenceEnums_Match_descriptor();
template <typename T>
const std::string& ASTForeignKeyReferenceEnums_Match_Name(T value) {
  static_assert(std::is_same<T, ASTForeignKeyReferenceEnums_Match>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Match_Name().");
  return ASTForeignKeyReferenceEnums_Match_Name(static_cast<ASTForeignKeyReferenceEnums_Match>(value));
}
template <>
inline const std::string& ASTForeignKeyReferenceEnums_Match_Name(ASTForeignKeyReferenceEnums_Match value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTForeignKeyReferenceEnums_Match_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool ASTForeignKeyReferenceEnums_Match_Parse(absl::string_view name, ASTForeignKeyReferenceEnums_Match* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTForeignKeyReferenceEnums_Match>(
      ASTForeignKeyReferenceEnums_Match_descriptor(), name, value);
}
enum ASTBreakContinueStatementEnums_BreakContinueKeyword : int {
  ASTBreakContinueStatementEnums_BreakContinueKeyword_BREAK = 1,
  ASTBreakContinueStatementEnums_BreakContinueKeyword_LEAVE = 2,
  ASTBreakContinueStatementEnums_BreakContinueKeyword_CONTINUE = 3,
  ASTBreakContinueStatementEnums_BreakContinueKeyword_ITERATE = 4,
};

bool ASTBreakContinueStatementEnums_BreakContinueKeyword_IsValid(int value);
extern const uint32_t ASTBreakContinueStatementEnums_BreakContinueKeyword_internal_data_[];
constexpr ASTBreakContinueStatementEnums_BreakContinueKeyword ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MIN = static_cast<ASTBreakContinueStatementEnums_BreakContinueKeyword>(1);
constexpr ASTBreakContinueStatementEnums_BreakContinueKeyword ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MAX = static_cast<ASTBreakContinueStatementEnums_BreakContinueKeyword>(4);
constexpr int ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor();
template <typename T>
const std::string& ASTBreakContinueStatementEnums_BreakContinueKeyword_Name(T value) {
  static_assert(std::is_same<T, ASTBreakContinueStatementEnums_BreakContinueKeyword>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BreakContinueKeyword_Name().");
  return ASTBreakContinueStatementEnums_BreakContinueKeyword_Name(static_cast<ASTBreakContinueStatementEnums_BreakContinueKeyword>(value));
}
template <>
inline const std::string& ASTBreakContinueStatementEnums_BreakContinueKeyword_Name(ASTBreakContinueStatementEnums_BreakContinueKeyword value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor,
                                                 1, 4>(
      static_cast<int>(value));
}
inline bool ASTBreakContinueStatementEnums_BreakContinueKeyword_Parse(absl::string_view name, ASTBreakContinueStatementEnums_BreakContinueKeyword* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTBreakContinueStatementEnums_BreakContinueKeyword>(
      ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor(), name, value);
}
enum ASTDropStatementEnums_DropMode : int {
  ASTDropStatementEnums_DropMode_DROP_MODE_UNSPECIFIED = 0,
  ASTDropStatementEnums_DropMode_RESTRICT = 1,
  ASTDropStatementEnums_DropMode_CASCADE = 2,
};

bool ASTDropStatementEnums_DropMode_IsValid(int value);
extern const uint32_t ASTDropStatementEnums_DropMode_internal_data_[];
constexpr ASTDropStatementEnums_DropMode ASTDropStatementEnums_DropMode_DropMode_MIN = static_cast<ASTDropStatementEnums_DropMode>(0);
constexpr ASTDropStatementEnums_DropMode ASTDropStatementEnums_DropMode_DropMode_MAX = static_cast<ASTDropStatementEnums_DropMode>(2);
constexpr int ASTDropStatementEnums_DropMode_DropMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTDropStatementEnums_DropMode_descriptor();
template <typename T>
const std::string& ASTDropStatementEnums_DropMode_Name(T value) {
  static_assert(std::is_same<T, ASTDropStatementEnums_DropMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DropMode_Name().");
  return ASTDropStatementEnums_DropMode_Name(static_cast<ASTDropStatementEnums_DropMode>(value));
}
template <>
inline const std::string& ASTDropStatementEnums_DropMode_Name(ASTDropStatementEnums_DropMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTDropStatementEnums_DropMode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTDropStatementEnums_DropMode_Parse(absl::string_view name, ASTDropStatementEnums_DropMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTDropStatementEnums_DropMode>(
      ASTDropStatementEnums_DropMode_descriptor(), name, value);
}
enum ASTCreateFunctionStmtBaseEnums_DeterminismLevel : int {
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED = 0,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISTIC = 1,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_NOT_DETERMINISTIC = 2,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IMMUTABLE = 3,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_STABLE = 4,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_VOLATILE = 5,
};

bool ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IsValid(int value);
extern const uint32_t ASTCreateFunctionStmtBaseEnums_DeterminismLevel_internal_data_[];
constexpr ASTCreateFunctionStmtBaseEnums_DeterminismLevel ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MIN = static_cast<ASTCreateFunctionStmtBaseEnums_DeterminismLevel>(0);
constexpr ASTCreateFunctionStmtBaseEnums_DeterminismLevel ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MAX = static_cast<ASTCreateFunctionStmtBaseEnums_DeterminismLevel>(5);
constexpr int ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor();
template <typename T>
const std::string& ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Name(T value) {
  static_assert(std::is_same<T, ASTCreateFunctionStmtBaseEnums_DeterminismLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DeterminismLevel_Name().");
  return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Name(static_cast<ASTCreateFunctionStmtBaseEnums_DeterminismLevel>(value));
}
template <>
inline const std::string& ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Name(ASTCreateFunctionStmtBaseEnums_DeterminismLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Parse(absl::string_view name, ASTCreateFunctionStmtBaseEnums_DeterminismLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTCreateFunctionStmtBaseEnums_DeterminismLevel>(
      ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor(), name, value);
}
enum ASTAuxLoadDataStatementEnums_InsertionMode : int {
  ASTAuxLoadDataStatementEnums_InsertionMode_NOT_SET = 0,
  ASTAuxLoadDataStatementEnums_InsertionMode_APPEND = 1,
  ASTAuxLoadDataStatementEnums_InsertionMode_OVERWRITE = 2,
};

bool ASTAuxLoadDataStatementEnums_InsertionMode_IsValid(int value);
extern const uint32_t ASTAuxLoadDataStatementEnums_InsertionMode_internal_data_[];
constexpr ASTAuxLoadDataStatementEnums_InsertionMode ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MIN = static_cast<ASTAuxLoadDataStatementEnums_InsertionMode>(0);
constexpr ASTAuxLoadDataStatementEnums_InsertionMode ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MAX = static_cast<ASTAuxLoadDataStatementEnums_InsertionMode>(2);
constexpr int ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTAuxLoadDataStatementEnums_InsertionMode_descriptor();
template <typename T>
const std::string& ASTAuxLoadDataStatementEnums_InsertionMode_Name(T value) {
  static_assert(std::is_same<T, ASTAuxLoadDataStatementEnums_InsertionMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InsertionMode_Name().");
  return ASTAuxLoadDataStatementEnums_InsertionMode_Name(static_cast<ASTAuxLoadDataStatementEnums_InsertionMode>(value));
}
template <>
inline const std::string& ASTAuxLoadDataStatementEnums_InsertionMode_Name(ASTAuxLoadDataStatementEnums_InsertionMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTAuxLoadDataStatementEnums_InsertionMode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTAuxLoadDataStatementEnums_InsertionMode_Parse(absl::string_view name, ASTAuxLoadDataStatementEnums_InsertionMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTAuxLoadDataStatementEnums_InsertionMode>(
      ASTAuxLoadDataStatementEnums_InsertionMode_descriptor(), name, value);
}
enum ASTSpannerInterleaveClauseEnums_Type : int {
  ASTSpannerInterleaveClauseEnums_Type_NOT_SET = 0,
  ASTSpannerInterleaveClauseEnums_Type_IN = 1,
  ASTSpannerInterleaveClauseEnums_Type_IN_PARENT = 2,
};

bool ASTSpannerInterleaveClauseEnums_Type_IsValid(int value);
extern const uint32_t ASTSpannerInterleaveClauseEnums_Type_internal_data_[];
constexpr ASTSpannerInterleaveClauseEnums_Type ASTSpannerInterleaveClauseEnums_Type_Type_MIN = static_cast<ASTSpannerInterleaveClauseEnums_Type>(0);
constexpr ASTSpannerInterleaveClauseEnums_Type ASTSpannerInterleaveClauseEnums_Type_Type_MAX = static_cast<ASTSpannerInterleaveClauseEnums_Type>(2);
constexpr int ASTSpannerInterleaveClauseEnums_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTSpannerInterleaveClauseEnums_Type_descriptor();
template <typename T>
const std::string& ASTSpannerInterleaveClauseEnums_Type_Name(T value) {
  static_assert(std::is_same<T, ASTSpannerInterleaveClauseEnums_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return ASTSpannerInterleaveClauseEnums_Type_Name(static_cast<ASTSpannerInterleaveClauseEnums_Type>(value));
}
template <>
inline const std::string& ASTSpannerInterleaveClauseEnums_Type_Name(ASTSpannerInterleaveClauseEnums_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTSpannerInterleaveClauseEnums_Type_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTSpannerInterleaveClauseEnums_Type_Parse(absl::string_view name, ASTSpannerInterleaveClauseEnums_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTSpannerInterleaveClauseEnums_Type>(
      ASTSpannerInterleaveClauseEnums_Type_descriptor(), name, value);
}
enum ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType : int {
  ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_AFTER_MATCH_SKIP_TARGET_UNSPECIFIED = 0,
  ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_PAST_LAST_ROW = 1,
  ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_TO_NEXT_ROW = 2,
};

bool ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_IsValid(int value);
extern const uint32_t ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_internal_data_[];
constexpr ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_AfterMatchSkipTargetType_MIN = static_cast<ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType>(0);
constexpr ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_AfterMatchSkipTargetType_MAX = static_cast<ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType>(2);
constexpr int ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_AfterMatchSkipTargetType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_descriptor();
template <typename T>
const std::string& ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_Name(T value) {
  static_assert(std::is_same<T, ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AfterMatchSkipTargetType_Name().");
  return ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_Name(static_cast<ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType>(value));
}
template <>
inline const std::string& ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_Name(ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_Parse(absl::string_view name, ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType>(
      ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_descriptor(), name, value);
}
enum ASTRowPatternAnchorEnums_Anchor : int {
  ASTRowPatternAnchorEnums_Anchor_ANCHOR_UNSPECIFIED = 0,
  ASTRowPatternAnchorEnums_Anchor_START = 1,
  ASTRowPatternAnchorEnums_Anchor_END = 2,
};

bool ASTRowPatternAnchorEnums_Anchor_IsValid(int value);
extern const uint32_t ASTRowPatternAnchorEnums_Anchor_internal_data_[];
constexpr ASTRowPatternAnchorEnums_Anchor ASTRowPatternAnchorEnums_Anchor_Anchor_MIN = static_cast<ASTRowPatternAnchorEnums_Anchor>(0);
constexpr ASTRowPatternAnchorEnums_Anchor ASTRowPatternAnchorEnums_Anchor_Anchor_MAX = static_cast<ASTRowPatternAnchorEnums_Anchor>(2);
constexpr int ASTRowPatternAnchorEnums_Anchor_Anchor_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTRowPatternAnchorEnums_Anchor_descriptor();
template <typename T>
const std::string& ASTRowPatternAnchorEnums_Anchor_Name(T value) {
  static_assert(std::is_same<T, ASTRowPatternAnchorEnums_Anchor>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Anchor_Name().");
  return ASTRowPatternAnchorEnums_Anchor_Name(static_cast<ASTRowPatternAnchorEnums_Anchor>(value));
}
template <>
inline const std::string& ASTRowPatternAnchorEnums_Anchor_Name(ASTRowPatternAnchorEnums_Anchor value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTRowPatternAnchorEnums_Anchor_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTRowPatternAnchorEnums_Anchor_Parse(absl::string_view name, ASTRowPatternAnchorEnums_Anchor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTRowPatternAnchorEnums_Anchor>(
      ASTRowPatternAnchorEnums_Anchor_descriptor(), name, value);
}
enum ASTRowPatternOperationEnums_OperationType : int {
  ASTRowPatternOperationEnums_OperationType_OPERATION_TYPE_UNSPECIFIED = 0,
  ASTRowPatternOperationEnums_OperationType_CONCAT = 1,
  ASTRowPatternOperationEnums_OperationType_ALTERNATE = 2,
  ASTRowPatternOperationEnums_OperationType_PERMUTE = 3,
  ASTRowPatternOperationEnums_OperationType_EXCLUDE = 4,
};

bool ASTRowPatternOperationEnums_OperationType_IsValid(int value);
extern const uint32_t ASTRowPatternOperationEnums_OperationType_internal_data_[];
constexpr ASTRowPatternOperationEnums_OperationType ASTRowPatternOperationEnums_OperationType_OperationType_MIN = static_cast<ASTRowPatternOperationEnums_OperationType>(0);
constexpr ASTRowPatternOperationEnums_OperationType ASTRowPatternOperationEnums_OperationType_OperationType_MAX = static_cast<ASTRowPatternOperationEnums_OperationType>(4);
constexpr int ASTRowPatternOperationEnums_OperationType_OperationType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ASTRowPatternOperationEnums_OperationType_descriptor();
template <typename T>
const std::string& ASTRowPatternOperationEnums_OperationType_Name(T value) {
  static_assert(std::is_same<T, ASTRowPatternOperationEnums_OperationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OperationType_Name().");
  return ASTRowPatternOperationEnums_OperationType_Name(static_cast<ASTRowPatternOperationEnums_OperationType>(value));
}
template <>
inline const std::string& ASTRowPatternOperationEnums_OperationType_Name(ASTRowPatternOperationEnums_OperationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTRowPatternOperationEnums_OperationType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ASTRowPatternOperationEnums_OperationType_Parse(absl::string_view name, ASTRowPatternOperationEnums_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTRowPatternOperationEnums_OperationType>(
      ASTRowPatternOperationEnums_OperationType_descriptor(), name, value);
}
enum ASTSymbolQuantifierEnums_Symbol : int {
  ASTSymbolQuantifierEnums_Symbol_SYMBOL_UNSPECIFIED = 0,
  ASTSymbolQuantifierEnums_Symbol_QUESTION_MARK = 1,
  ASTSymbolQuantifierEnums_Symbol_PLUS = 2,
  ASTSymbolQuantifierEnums_Symbol_STAR = 3,
};

bool ASTSymbolQuantifierEnums_Symbol_IsValid(int value);
extern const uint32_t ASTSymbolQuantifierEnums_Symbol_internal_data_[];
constexpr ASTSymbolQuantifierEnums_Symbol ASTSymbolQuantifierEnums_Symbol_Symbol_MIN = static_cast<ASTSymbolQuantifierEnums_Symbol>(0);
constexpr ASTSymbolQuantifierEnums_Symbol ASTSymbolQuantifierEnums_Symbol_Symbol_MAX = static_cast<ASTSymbolQuantifierEnums_Symbol>(3);
constexpr int ASTSymbolQuantifierEnums_Symbol_Symbol_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTSymbolQuantifierEnums_Symbol_descriptor();
template <typename T>
const std::string& ASTSymbolQuantifierEnums_Symbol_Name(T value) {
  static_assert(std::is_same<T, ASTSymbolQuantifierEnums_Symbol>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Symbol_Name().");
  return ASTSymbolQuantifierEnums_Symbol_Name(static_cast<ASTSymbolQuantifierEnums_Symbol>(value));
}
template <>
inline const std::string& ASTSymbolQuantifierEnums_Symbol_Name(ASTSymbolQuantifierEnums_Symbol value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTSymbolQuantifierEnums_Symbol_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTSymbolQuantifierEnums_Symbol_Parse(absl::string_view name, ASTSymbolQuantifierEnums_Symbol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTSymbolQuantifierEnums_Symbol>(
      ASTSymbolQuantifierEnums_Symbol_descriptor(), name, value);
}
enum ASTGraphNodeTableReferenceEnums_NodeReferenceType : int {
  ASTGraphNodeTableReferenceEnums_NodeReferenceType_NODE_REFERENCE_TYPE_UNSPECIFIED = 0,
  ASTGraphNodeTableReferenceEnums_NodeReferenceType_SOURCE = 1,
  ASTGraphNodeTableReferenceEnums_NodeReferenceType_DESTINATION = 2,
};

bool ASTGraphNodeTableReferenceEnums_NodeReferenceType_IsValid(int value);
extern const uint32_t ASTGraphNodeTableReferenceEnums_NodeReferenceType_internal_data_[];
constexpr ASTGraphNodeTableReferenceEnums_NodeReferenceType ASTGraphNodeTableReferenceEnums_NodeReferenceType_NodeReferenceType_MIN = static_cast<ASTGraphNodeTableReferenceEnums_NodeReferenceType>(0);
constexpr ASTGraphNodeTableReferenceEnums_NodeReferenceType ASTGraphNodeTableReferenceEnums_NodeReferenceType_NodeReferenceType_MAX = static_cast<ASTGraphNodeTableReferenceEnums_NodeReferenceType>(2);
constexpr int ASTGraphNodeTableReferenceEnums_NodeReferenceType_NodeReferenceType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTGraphNodeTableReferenceEnums_NodeReferenceType_descriptor();
template <typename T>
const std::string& ASTGraphNodeTableReferenceEnums_NodeReferenceType_Name(T value) {
  static_assert(std::is_same<T, ASTGraphNodeTableReferenceEnums_NodeReferenceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NodeReferenceType_Name().");
  return ASTGraphNodeTableReferenceEnums_NodeReferenceType_Name(static_cast<ASTGraphNodeTableReferenceEnums_NodeReferenceType>(value));
}
template <>
inline const std::string& ASTGraphNodeTableReferenceEnums_NodeReferenceType_Name(ASTGraphNodeTableReferenceEnums_NodeReferenceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTGraphNodeTableReferenceEnums_NodeReferenceType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTGraphNodeTableReferenceEnums_NodeReferenceType_Parse(absl::string_view name, ASTGraphNodeTableReferenceEnums_NodeReferenceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTGraphNodeTableReferenceEnums_NodeReferenceType>(
      ASTGraphNodeTableReferenceEnums_NodeReferenceType_descriptor(), name, value);
}
enum ASTGraphLabelOperationEnums_OperationType : int {
  ASTGraphLabelOperationEnums_OperationType_OPERATION_TYPE_UNSPECIFIED = 0,
  ASTGraphLabelOperationEnums_OperationType_NOT = 1,
  ASTGraphLabelOperationEnums_OperationType_AND = 2,
  ASTGraphLabelOperationEnums_OperationType_OR = 3,
};

bool ASTGraphLabelOperationEnums_OperationType_IsValid(int value);
extern const uint32_t ASTGraphLabelOperationEnums_OperationType_internal_data_[];
constexpr ASTGraphLabelOperationEnums_OperationType ASTGraphLabelOperationEnums_OperationType_OperationType_MIN = static_cast<ASTGraphLabelOperationEnums_OperationType>(0);
constexpr ASTGraphLabelOperationEnums_OperationType ASTGraphLabelOperationEnums_OperationType_OperationType_MAX = static_cast<ASTGraphLabelOperationEnums_OperationType>(3);
constexpr int ASTGraphLabelOperationEnums_OperationType_OperationType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTGraphLabelOperationEnums_OperationType_descriptor();
template <typename T>
const std::string& ASTGraphLabelOperationEnums_OperationType_Name(T value) {
  static_assert(std::is_same<T, ASTGraphLabelOperationEnums_OperationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OperationType_Name().");
  return ASTGraphLabelOperationEnums_OperationType_Name(static_cast<ASTGraphLabelOperationEnums_OperationType>(value));
}
template <>
inline const std::string& ASTGraphLabelOperationEnums_OperationType_Name(ASTGraphLabelOperationEnums_OperationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTGraphLabelOperationEnums_OperationType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTGraphLabelOperationEnums_OperationType_Parse(absl::string_view name, ASTGraphLabelOperationEnums_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTGraphLabelOperationEnums_OperationType>(
      ASTGraphLabelOperationEnums_OperationType_descriptor(), name, value);
}
enum ASTGraphEdgePatternEnums_EdgeOrientation : int {
  ASTGraphEdgePatternEnums_EdgeOrientation_EDGE_ORIENTATION_NOT_SET = 0,
  ASTGraphEdgePatternEnums_EdgeOrientation_ANY = 1,
  ASTGraphEdgePatternEnums_EdgeOrientation_LEFT = 2,
  ASTGraphEdgePatternEnums_EdgeOrientation_RIGHT = 3,
};

bool ASTGraphEdgePatternEnums_EdgeOrientation_IsValid(int value);
extern const uint32_t ASTGraphEdgePatternEnums_EdgeOrientation_internal_data_[];
constexpr ASTGraphEdgePatternEnums_EdgeOrientation ASTGraphEdgePatternEnums_EdgeOrientation_EdgeOrientation_MIN = static_cast<ASTGraphEdgePatternEnums_EdgeOrientation>(0);
constexpr ASTGraphEdgePatternEnums_EdgeOrientation ASTGraphEdgePatternEnums_EdgeOrientation_EdgeOrientation_MAX = static_cast<ASTGraphEdgePatternEnums_EdgeOrientation>(3);
constexpr int ASTGraphEdgePatternEnums_EdgeOrientation_EdgeOrientation_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ASTGraphEdgePatternEnums_EdgeOrientation_descriptor();
template <typename T>
const std::string& ASTGraphEdgePatternEnums_EdgeOrientation_Name(T value) {
  static_assert(std::is_same<T, ASTGraphEdgePatternEnums_EdgeOrientation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EdgeOrientation_Name().");
  return ASTGraphEdgePatternEnums_EdgeOrientation_Name(static_cast<ASTGraphEdgePatternEnums_EdgeOrientation>(value));
}
template <>
inline const std::string& ASTGraphEdgePatternEnums_EdgeOrientation_Name(ASTGraphEdgePatternEnums_EdgeOrientation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTGraphEdgePatternEnums_EdgeOrientation_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ASTGraphEdgePatternEnums_EdgeOrientation_Parse(absl::string_view name, ASTGraphEdgePatternEnums_EdgeOrientation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTGraphEdgePatternEnums_EdgeOrientation>(
      ASTGraphEdgePatternEnums_EdgeOrientation_descriptor(), name, value);
}
enum ASTGraphPathModeEnums_PathMode : int {
  ASTGraphPathModeEnums_PathMode_PATH_MODE_UNSPECIFIED = 0,
  ASTGraphPathModeEnums_PathMode_WALK = 1,
  ASTGraphPathModeEnums_PathMode_TRAIL = 2,
  ASTGraphPathModeEnums_PathMode_SIMPLE = 3,
  ASTGraphPathModeEnums_PathMode_ACYCLIC = 4,
};

bool ASTGraphPathModeEnums_PathMode_IsValid(int value);
extern const uint32_t ASTGraphPathModeEnums_PathMode_internal_data_[];
constexpr ASTGraphPathModeEnums_PathMode ASTGraphPathModeEnums_PathMode_PathMode_MIN = static_cast<ASTGraphPathModeEnums_PathMode>(0);
constexpr ASTGraphPathModeEnums_PathMode ASTGraphPathModeEnums_PathMode_PathMode_MAX = static_cast<ASTGraphPathModeEnums_PathMode>(4);
constexpr int ASTGraphPathModeEnums_PathMode_PathMode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ASTGraphPathModeEnums_PathMode_descriptor();
template <typename T>
const std::string& ASTGraphPathModeEnums_PathMode_Name(T value) {
  static_assert(std::is_same<T, ASTGraphPathModeEnums_PathMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PathMode_Name().");
  return ASTGraphPathModeEnums_PathMode_Name(static_cast<ASTGraphPathModeEnums_PathMode>(value));
}
template <>
inline const std::string& ASTGraphPathModeEnums_PathMode_Name(ASTGraphPathModeEnums_PathMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTGraphPathModeEnums_PathMode_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ASTGraphPathModeEnums_PathMode_Parse(absl::string_view name, ASTGraphPathModeEnums_PathMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTGraphPathModeEnums_PathMode>(
      ASTGraphPathModeEnums_PathMode_descriptor(), name, value);
}
enum ASTGraphPathSearchPrefixEnums_PathSearchPrefixType : int {
  ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_PATH_SEARCH_PREFIX_TYPE_UNSPECIFIED = 0,
  ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_ANY = 1,
  ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_SHORTEST = 2,
  ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_ALL = 3,
  ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_ALL_SHORTEST = 4,
  ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_CHEAPEST = 5,
  ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_ALL_CHEAPEST = 6,
};

bool ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_IsValid(int value);
extern const uint32_t ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_internal_data_[];
constexpr ASTGraphPathSearchPrefixEnums_PathSearchPrefixType ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_PathSearchPrefixType_MIN = static_cast<ASTGraphPathSearchPrefixEnums_PathSearchPrefixType>(0);
constexpr ASTGraphPathSearchPrefixEnums_PathSearchPrefixType ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_PathSearchPrefixType_MAX = static_cast<ASTGraphPathSearchPrefixEnums_PathSearchPrefixType>(6);
constexpr int ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_PathSearchPrefixType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_descriptor();
template <typename T>
const std::string& ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_Name(T value) {
  static_assert(std::is_same<T, ASTGraphPathSearchPrefixEnums_PathSearchPrefixType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PathSearchPrefixType_Name().");
  return ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_Name(static_cast<ASTGraphPathSearchPrefixEnums_PathSearchPrefixType>(value));
}
template <>
inline const std::string& ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_Name(ASTGraphPathSearchPrefixEnums_PathSearchPrefixType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_Parse(absl::string_view name, ASTGraphPathSearchPrefixEnums_PathSearchPrefixType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTGraphPathSearchPrefixEnums_PathSearchPrefixType>(
      ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_descriptor(), name, value);
}
enum ASTLockModeEnums_LockStrengthSpec : int {
  ASTLockModeEnums_LockStrengthSpec_NOT_SET = 0,
  ASTLockModeEnums_LockStrengthSpec_UPDATE = 1,
};

bool ASTLockModeEnums_LockStrengthSpec_IsValid(int value);
extern const uint32_t ASTLockModeEnums_LockStrengthSpec_internal_data_[];
constexpr ASTLockModeEnums_LockStrengthSpec ASTLockModeEnums_LockStrengthSpec_LockStrengthSpec_MIN = static_cast<ASTLockModeEnums_LockStrengthSpec>(0);
constexpr ASTLockModeEnums_LockStrengthSpec ASTLockModeEnums_LockStrengthSpec_LockStrengthSpec_MAX = static_cast<ASTLockModeEnums_LockStrengthSpec>(1);
constexpr int ASTLockModeEnums_LockStrengthSpec_LockStrengthSpec_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ASTLockModeEnums_LockStrengthSpec_descriptor();
template <typename T>
const std::string& ASTLockModeEnums_LockStrengthSpec_Name(T value) {
  static_assert(std::is_same<T, ASTLockModeEnums_LockStrengthSpec>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LockStrengthSpec_Name().");
  return ASTLockModeEnums_LockStrengthSpec_Name(static_cast<ASTLockModeEnums_LockStrengthSpec>(value));
}
template <>
inline const std::string& ASTLockModeEnums_LockStrengthSpec_Name(ASTLockModeEnums_LockStrengthSpec value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTLockModeEnums_LockStrengthSpec_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ASTLockModeEnums_LockStrengthSpec_Parse(absl::string_view name, ASTLockModeEnums_LockStrengthSpec* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTLockModeEnums_LockStrengthSpec>(
      ASTLockModeEnums_LockStrengthSpec_descriptor(), name, value);
}
enum ASTBracedConstructorLhsEnums_Operation : int {
  ASTBracedConstructorLhsEnums_Operation_UPDATE_SINGLE = 0,
  ASTBracedConstructorLhsEnums_Operation_UPDATE_MANY = 1,
  ASTBracedConstructorLhsEnums_Operation_UPDATE_SINGLE_NO_CREATION = 2,
};

bool ASTBracedConstructorLhsEnums_Operation_IsValid(int value);
extern const uint32_t ASTBracedConstructorLhsEnums_Operation_internal_data_[];
constexpr ASTBracedConstructorLhsEnums_Operation ASTBracedConstructorLhsEnums_Operation_Operation_MIN = static_cast<ASTBracedConstructorLhsEnums_Operation>(0);
constexpr ASTBracedConstructorLhsEnums_Operation ASTBracedConstructorLhsEnums_Operation_Operation_MAX = static_cast<ASTBracedConstructorLhsEnums_Operation>(2);
constexpr int ASTBracedConstructorLhsEnums_Operation_Operation_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTBracedConstructorLhsEnums_Operation_descriptor();
template <typename T>
const std::string& ASTBracedConstructorLhsEnums_Operation_Name(T value) {
  static_assert(std::is_same<T, ASTBracedConstructorLhsEnums_Operation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Operation_Name().");
  return ASTBracedConstructorLhsEnums_Operation_Name(static_cast<ASTBracedConstructorLhsEnums_Operation>(value));
}
template <>
inline const std::string& ASTBracedConstructorLhsEnums_Operation_Name(ASTBracedConstructorLhsEnums_Operation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTBracedConstructorLhsEnums_Operation_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTBracedConstructorLhsEnums_Operation_Parse(absl::string_view name, ASTBracedConstructorLhsEnums_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTBracedConstructorLhsEnums_Operation>(
      ASTBracedConstructorLhsEnums_Operation_descriptor(), name, value);
}
enum ASTAlterIndexStatementEnums_IndexType : int {
  ASTAlterIndexStatementEnums_IndexType_INDEX_DEFAULT = 0,
  ASTAlterIndexStatementEnums_IndexType_INDEX_SEARCH = 1,
  ASTAlterIndexStatementEnums_IndexType_INDEX_VECTOR = 2,
};

bool ASTAlterIndexStatementEnums_IndexType_IsValid(int value);
extern const uint32_t ASTAlterIndexStatementEnums_IndexType_internal_data_[];
constexpr ASTAlterIndexStatementEnums_IndexType ASTAlterIndexStatementEnums_IndexType_IndexType_MIN = static_cast<ASTAlterIndexStatementEnums_IndexType>(0);
constexpr ASTAlterIndexStatementEnums_IndexType ASTAlterIndexStatementEnums_IndexType_IndexType_MAX = static_cast<ASTAlterIndexStatementEnums_IndexType>(2);
constexpr int ASTAlterIndexStatementEnums_IndexType_IndexType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ASTAlterIndexStatementEnums_IndexType_descriptor();
template <typename T>
const std::string& ASTAlterIndexStatementEnums_IndexType_Name(T value) {
  static_assert(std::is_same<T, ASTAlterIndexStatementEnums_IndexType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IndexType_Name().");
  return ASTAlterIndexStatementEnums_IndexType_Name(static_cast<ASTAlterIndexStatementEnums_IndexType>(value));
}
template <>
inline const std::string& ASTAlterIndexStatementEnums_IndexType_Name(ASTAlterIndexStatementEnums_IndexType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ASTAlterIndexStatementEnums_IndexType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ASTAlterIndexStatementEnums_IndexType_Parse(absl::string_view name, ASTAlterIndexStatementEnums_IndexType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTAlterIndexStatementEnums_IndexType>(
      ASTAlterIndexStatementEnums_IndexType_descriptor(), name, value);
}
enum SchemaObjectKind : int {
  __SchemaObjectKind__switch_must_have_a_default__ = -1,
  kInvalidSchemaObjectKind = 1,
  kAggregateFunction = 2,
  kApproxView = 17,
  kConnection = 19,
  kConstant = 3,
  kDatabase = 4,
  kExternalTable = 5,
  kFunction = 6,
  kIndex = 7,
  kMaterializedView = 8,
  kModel = 9,
  kProcedure = 10,
  kSchema = 11,
  kTable = 12,
  kTableFunction = 13,
  kView = 14,
  kSnapshotTable = 15,
  kPropertyGraph = 16,
  kExternalSchema = 18,
  kSequence = 20,
};

bool SchemaObjectKind_IsValid(int value);
extern const uint32_t SchemaObjectKind_internal_data_[];
constexpr SchemaObjectKind SchemaObjectKind_MIN = static_cast<SchemaObjectKind>(-1);
constexpr SchemaObjectKind SchemaObjectKind_MAX = static_cast<SchemaObjectKind>(20);
constexpr int SchemaObjectKind_ARRAYSIZE = 20 + 1;
const ::google::protobuf::EnumDescriptor*
SchemaObjectKind_descriptor();
template <typename T>
const std::string& SchemaObjectKind_Name(T value) {
  static_assert(std::is_same<T, SchemaObjectKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SchemaObjectKind_Name().");
  return SchemaObjectKind_Name(static_cast<SchemaObjectKind>(value));
}
template <>
inline const std::string& SchemaObjectKind_Name(SchemaObjectKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SchemaObjectKind_descriptor,
                                                 -1, 20>(
      static_cast<int>(value));
}
inline bool SchemaObjectKind_Parse(absl::string_view name, SchemaObjectKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SchemaObjectKind>(
      SchemaObjectKind_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ASTWindowFrameExprEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTWindowFrameExprEnums) */ {
 public:
  inline ASTWindowFrameExprEnums() : ASTWindowFrameExprEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTWindowFrameExprEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTWindowFrameExprEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTWindowFrameExprEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTWindowFrameExprEnums(const ASTWindowFrameExprEnums& from) : ASTWindowFrameExprEnums(nullptr, from) {}
  inline ASTWindowFrameExprEnums(ASTWindowFrameExprEnums&& from) noexcept
      : ASTWindowFrameExprEnums(nullptr, std::move(from)) {}
  inline ASTWindowFrameExprEnums& operator=(const ASTWindowFrameExprEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTWindowFrameExprEnums& operator=(ASTWindowFrameExprEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTWindowFrameExprEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTWindowFrameExprEnums* internal_default_instance() {
    return reinterpret_cast<const ASTWindowFrameExprEnums*>(
        &_ASTWindowFrameExprEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ASTWindowFrameExprEnums& a, ASTWindowFrameExprEnums& b) { a.Swap(&b); }
  inline void Swap(ASTWindowFrameExprEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTWindowFrameExprEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTWindowFrameExprEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTWindowFrameExprEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTWindowFrameExprEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTWindowFrameExprEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTWindowFrameExprEnums"; }

 protected:
  explicit ASTWindowFrameExprEnums(::google::protobuf::Arena* arena);
  ASTWindowFrameExprEnums(::google::protobuf::Arena* arena, const ASTWindowFrameExprEnums& from);
  ASTWindowFrameExprEnums(::google::protobuf::Arena* arena, ASTWindowFrameExprEnums&& from) noexcept
      : ASTWindowFrameExprEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using BoundaryType = ASTWindowFrameExprEnums_BoundaryType;
  static constexpr BoundaryType UNBOUNDED_PRECEDING = ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING;
  static constexpr BoundaryType OFFSET_PRECEDING = ASTWindowFrameExprEnums_BoundaryType_OFFSET_PRECEDING;
  static constexpr BoundaryType CURRENT_ROW = ASTWindowFrameExprEnums_BoundaryType_CURRENT_ROW;
  static constexpr BoundaryType OFFSET_FOLLOWING = ASTWindowFrameExprEnums_BoundaryType_OFFSET_FOLLOWING;
  static constexpr BoundaryType UNBOUNDED_FOLLOWING = ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING;
  static inline bool BoundaryType_IsValid(int value) {
    return ASTWindowFrameExprEnums_BoundaryType_IsValid(value);
  }
  static constexpr BoundaryType BoundaryType_MIN = ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MIN;
  static constexpr BoundaryType BoundaryType_MAX = ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MAX;
  static constexpr int BoundaryType_ARRAYSIZE = ASTWindowFrameExprEnums_BoundaryType_BoundaryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BoundaryType_descriptor() {
    return ASTWindowFrameExprEnums_BoundaryType_descriptor();
  }
  template <typename T>
  static inline const std::string& BoundaryType_Name(T value) {
    return ASTWindowFrameExprEnums_BoundaryType_Name(value);
  }
  static inline bool BoundaryType_Parse(absl::string_view name, BoundaryType* value) {
    return ASTWindowFrameExprEnums_BoundaryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTWindowFrameExprEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTWindowFrameExprEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTWindowFrameEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTWindowFrameEnums) */ {
 public:
  inline ASTWindowFrameEnums() : ASTWindowFrameEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTWindowFrameEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTWindowFrameEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTWindowFrameEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTWindowFrameEnums(const ASTWindowFrameEnums& from) : ASTWindowFrameEnums(nullptr, from) {}
  inline ASTWindowFrameEnums(ASTWindowFrameEnums&& from) noexcept
      : ASTWindowFrameEnums(nullptr, std::move(from)) {}
  inline ASTWindowFrameEnums& operator=(const ASTWindowFrameEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTWindowFrameEnums& operator=(ASTWindowFrameEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTWindowFrameEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTWindowFrameEnums* internal_default_instance() {
    return reinterpret_cast<const ASTWindowFrameEnums*>(
        &_ASTWindowFrameEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ASTWindowFrameEnums& a, ASTWindowFrameEnums& b) { a.Swap(&b); }
  inline void Swap(ASTWindowFrameEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTWindowFrameEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTWindowFrameEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTWindowFrameEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTWindowFrameEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTWindowFrameEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTWindowFrameEnums"; }

 protected:
  explicit ASTWindowFrameEnums(::google::protobuf::Arena* arena);
  ASTWindowFrameEnums(::google::protobuf::Arena* arena, const ASTWindowFrameEnums& from);
  ASTWindowFrameEnums(::google::protobuf::Arena* arena, ASTWindowFrameEnums&& from) noexcept
      : ASTWindowFrameEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using FrameUnit = ASTWindowFrameEnums_FrameUnit;
  static constexpr FrameUnit ROWS = ASTWindowFrameEnums_FrameUnit_ROWS;
  static constexpr FrameUnit RANGE = ASTWindowFrameEnums_FrameUnit_RANGE;
  static inline bool FrameUnit_IsValid(int value) {
    return ASTWindowFrameEnums_FrameUnit_IsValid(value);
  }
  static constexpr FrameUnit FrameUnit_MIN = ASTWindowFrameEnums_FrameUnit_FrameUnit_MIN;
  static constexpr FrameUnit FrameUnit_MAX = ASTWindowFrameEnums_FrameUnit_FrameUnit_MAX;
  static constexpr int FrameUnit_ARRAYSIZE = ASTWindowFrameEnums_FrameUnit_FrameUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FrameUnit_descriptor() {
    return ASTWindowFrameEnums_FrameUnit_descriptor();
  }
  template <typename T>
  static inline const std::string& FrameUnit_Name(T value) {
    return ASTWindowFrameEnums_FrameUnit_Name(value);
  }
  static inline bool FrameUnit_Parse(absl::string_view name, FrameUnit* value) {
    return ASTWindowFrameEnums_FrameUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTWindowFrameEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTWindowFrameEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTUnpivotClauseEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTUnpivotClauseEnums) */ {
 public:
  inline ASTUnpivotClauseEnums() : ASTUnpivotClauseEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTUnpivotClauseEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTUnpivotClauseEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTUnpivotClauseEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTUnpivotClauseEnums(const ASTUnpivotClauseEnums& from) : ASTUnpivotClauseEnums(nullptr, from) {}
  inline ASTUnpivotClauseEnums(ASTUnpivotClauseEnums&& from) noexcept
      : ASTUnpivotClauseEnums(nullptr, std::move(from)) {}
  inline ASTUnpivotClauseEnums& operator=(const ASTUnpivotClauseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTUnpivotClauseEnums& operator=(ASTUnpivotClauseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTUnpivotClauseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTUnpivotClauseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTUnpivotClauseEnums*>(
        &_ASTUnpivotClauseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ASTUnpivotClauseEnums& a, ASTUnpivotClauseEnums& b) { a.Swap(&b); }
  inline void Swap(ASTUnpivotClauseEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTUnpivotClauseEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTUnpivotClauseEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTUnpivotClauseEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTUnpivotClauseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTUnpivotClauseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTUnpivotClauseEnums"; }

 protected:
  explicit ASTUnpivotClauseEnums(::google::protobuf::Arena* arena);
  ASTUnpivotClauseEnums(::google::protobuf::Arena* arena, const ASTUnpivotClauseEnums& from);
  ASTUnpivotClauseEnums(::google::protobuf::Arena* arena, ASTUnpivotClauseEnums&& from) noexcept
      : ASTUnpivotClauseEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using NullFilter = ASTUnpivotClauseEnums_NullFilter;
  static constexpr NullFilter kUnspecified = ASTUnpivotClauseEnums_NullFilter_kUnspecified;
  static constexpr NullFilter kInclude = ASTUnpivotClauseEnums_NullFilter_kInclude;
  static constexpr NullFilter kExclude = ASTUnpivotClauseEnums_NullFilter_kExclude;
  static inline bool NullFilter_IsValid(int value) {
    return ASTUnpivotClauseEnums_NullFilter_IsValid(value);
  }
  static constexpr NullFilter NullFilter_MIN = ASTUnpivotClauseEnums_NullFilter_NullFilter_MIN;
  static constexpr NullFilter NullFilter_MAX = ASTUnpivotClauseEnums_NullFilter_NullFilter_MAX;
  static constexpr int NullFilter_ARRAYSIZE = ASTUnpivotClauseEnums_NullFilter_NullFilter_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* NullFilter_descriptor() {
    return ASTUnpivotClauseEnums_NullFilter_descriptor();
  }
  template <typename T>
  static inline const std::string& NullFilter_Name(T value) {
    return ASTUnpivotClauseEnums_NullFilter_Name(value);
  }
  static inline bool NullFilter_Parse(absl::string_view name, NullFilter* value) {
    return ASTUnpivotClauseEnums_NullFilter_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTUnpivotClauseEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTUnpivotClauseEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTUnaryExpressionEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTUnaryExpressionEnums) */ {
 public:
  inline ASTUnaryExpressionEnums() : ASTUnaryExpressionEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTUnaryExpressionEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTUnaryExpressionEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTUnaryExpressionEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTUnaryExpressionEnums(const ASTUnaryExpressionEnums& from) : ASTUnaryExpressionEnums(nullptr, from) {}
  inline ASTUnaryExpressionEnums(ASTUnaryExpressionEnums&& from) noexcept
      : ASTUnaryExpressionEnums(nullptr, std::move(from)) {}
  inline ASTUnaryExpressionEnums& operator=(const ASTUnaryExpressionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTUnaryExpressionEnums& operator=(ASTUnaryExpressionEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTUnaryExpressionEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTUnaryExpressionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTUnaryExpressionEnums*>(
        &_ASTUnaryExpressionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ASTUnaryExpressionEnums& a, ASTUnaryExpressionEnums& b) { a.Swap(&b); }
  inline void Swap(ASTUnaryExpressionEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTUnaryExpressionEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTUnaryExpressionEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTUnaryExpressionEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTUnaryExpressionEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTUnaryExpressionEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTUnaryExpressionEnums"; }

 protected:
  explicit ASTUnaryExpressionEnums(::google::protobuf::Arena* arena);
  ASTUnaryExpressionEnums(::google::protobuf::Arena* arena, const ASTUnaryExpressionEnums& from);
  ASTUnaryExpressionEnums(::google::protobuf::Arena* arena, ASTUnaryExpressionEnums&& from) noexcept
      : ASTUnaryExpressionEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Op = ASTUnaryExpressionEnums_Op;
  static constexpr Op NOT_SET = ASTUnaryExpressionEnums_Op_NOT_SET;
  static constexpr Op NOT = ASTUnaryExpressionEnums_Op_NOT;
  static constexpr Op BITWISE_NOT = ASTUnaryExpressionEnums_Op_BITWISE_NOT;
  static constexpr Op MINUS = ASTUnaryExpressionEnums_Op_MINUS;
  static constexpr Op PLUS = ASTUnaryExpressionEnums_Op_PLUS;
  static constexpr Op IS_UNKNOWN = ASTUnaryExpressionEnums_Op_IS_UNKNOWN;
  static constexpr Op IS_NOT_UNKNOWN = ASTUnaryExpressionEnums_Op_IS_NOT_UNKNOWN;
  static inline bool Op_IsValid(int value) {
    return ASTUnaryExpressionEnums_Op_IsValid(value);
  }
  static constexpr Op Op_MIN = ASTUnaryExpressionEnums_Op_Op_MIN;
  static constexpr Op Op_MAX = ASTUnaryExpressionEnums_Op_Op_MAX;
  static constexpr int Op_ARRAYSIZE = ASTUnaryExpressionEnums_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Op_descriptor() {
    return ASTUnaryExpressionEnums_Op_descriptor();
  }
  template <typename T>
  static inline const std::string& Op_Name(T value) {
    return ASTUnaryExpressionEnums_Op_Name(value);
  }
  static inline bool Op_Parse(absl::string_view name, Op* value) {
    return ASTUnaryExpressionEnums_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTUnaryExpressionEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTUnaryExpressionEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTTransactionReadWriteModeEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTTransactionReadWriteModeEnums) */ {
 public:
  inline ASTTransactionReadWriteModeEnums() : ASTTransactionReadWriteModeEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTTransactionReadWriteModeEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTTransactionReadWriteModeEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTTransactionReadWriteModeEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTTransactionReadWriteModeEnums(const ASTTransactionReadWriteModeEnums& from) : ASTTransactionReadWriteModeEnums(nullptr, from) {}
  inline ASTTransactionReadWriteModeEnums(ASTTransactionReadWriteModeEnums&& from) noexcept
      : ASTTransactionReadWriteModeEnums(nullptr, std::move(from)) {}
  inline ASTTransactionReadWriteModeEnums& operator=(const ASTTransactionReadWriteModeEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTTransactionReadWriteModeEnums& operator=(ASTTransactionReadWriteModeEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTTransactionReadWriteModeEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTTransactionReadWriteModeEnums* internal_default_instance() {
    return reinterpret_cast<const ASTTransactionReadWriteModeEnums*>(
        &_ASTTransactionReadWriteModeEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ASTTransactionReadWriteModeEnums& a, ASTTransactionReadWriteModeEnums& b) { a.Swap(&b); }
  inline void Swap(ASTTransactionReadWriteModeEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTTransactionReadWriteModeEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTTransactionReadWriteModeEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTTransactionReadWriteModeEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTTransactionReadWriteModeEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTTransactionReadWriteModeEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTTransactionReadWriteModeEnums"; }

 protected:
  explicit ASTTransactionReadWriteModeEnums(::google::protobuf::Arena* arena);
  ASTTransactionReadWriteModeEnums(::google::protobuf::Arena* arena, const ASTTransactionReadWriteModeEnums& from);
  ASTTransactionReadWriteModeEnums(::google::protobuf::Arena* arena, ASTTransactionReadWriteModeEnums&& from) noexcept
      : ASTTransactionReadWriteModeEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Mode = ASTTransactionReadWriteModeEnums_Mode;
  static constexpr Mode INVALID = ASTTransactionReadWriteModeEnums_Mode_INVALID;
  static constexpr Mode READ_ONLY = ASTTransactionReadWriteModeEnums_Mode_READ_ONLY;
  static constexpr Mode READ_WRITE = ASTTransactionReadWriteModeEnums_Mode_READ_WRITE;
  static inline bool Mode_IsValid(int value) {
    return ASTTransactionReadWriteModeEnums_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN = ASTTransactionReadWriteModeEnums_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX = ASTTransactionReadWriteModeEnums_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE = ASTTransactionReadWriteModeEnums_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Mode_descriptor() {
    return ASTTransactionReadWriteModeEnums_Mode_descriptor();
  }
  template <typename T>
  static inline const std::string& Mode_Name(T value) {
    return ASTTransactionReadWriteModeEnums_Mode_Name(value);
  }
  static inline bool Mode_Parse(absl::string_view name, Mode* value) {
    return ASTTransactionReadWriteModeEnums_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTTransactionReadWriteModeEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTTransactionReadWriteModeEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTTemplatedParameterTypeEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTTemplatedParameterTypeEnums) */ {
 public:
  inline ASTTemplatedParameterTypeEnums() : ASTTemplatedParameterTypeEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTTemplatedParameterTypeEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTTemplatedParameterTypeEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTTemplatedParameterTypeEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTTemplatedParameterTypeEnums(const ASTTemplatedParameterTypeEnums& from) : ASTTemplatedParameterTypeEnums(nullptr, from) {}
  inline ASTTemplatedParameterTypeEnums(ASTTemplatedParameterTypeEnums&& from) noexcept
      : ASTTemplatedParameterTypeEnums(nullptr, std::move(from)) {}
  inline ASTTemplatedParameterTypeEnums& operator=(const ASTTemplatedParameterTypeEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTTemplatedParameterTypeEnums& operator=(ASTTemplatedParameterTypeEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTTemplatedParameterTypeEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTTemplatedParameterTypeEnums* internal_default_instance() {
    return reinterpret_cast<const ASTTemplatedParameterTypeEnums*>(
        &_ASTTemplatedParameterTypeEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ASTTemplatedParameterTypeEnums& a, ASTTemplatedParameterTypeEnums& b) { a.Swap(&b); }
  inline void Swap(ASTTemplatedParameterTypeEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTTemplatedParameterTypeEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTTemplatedParameterTypeEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTTemplatedParameterTypeEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTTemplatedParameterTypeEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTTemplatedParameterTypeEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTTemplatedParameterTypeEnums"; }

 protected:
  explicit ASTTemplatedParameterTypeEnums(::google::protobuf::Arena* arena);
  ASTTemplatedParameterTypeEnums(::google::protobuf::Arena* arena, const ASTTemplatedParameterTypeEnums& from);
  ASTTemplatedParameterTypeEnums(::google::protobuf::Arena* arena, ASTTemplatedParameterTypeEnums&& from) noexcept
      : ASTTemplatedParameterTypeEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TemplatedTypeKind = ASTTemplatedParameterTypeEnums_TemplatedTypeKind;
  static constexpr TemplatedTypeKind UNINITIALIZED = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_UNINITIALIZED;
  static constexpr TemplatedTypeKind ANY_TYPE = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TYPE;
  static constexpr TemplatedTypeKind ANY_PROTO = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_PROTO;
  static constexpr TemplatedTypeKind ANY_ENUM = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ENUM;
  static constexpr TemplatedTypeKind ANY_STRUCT = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_STRUCT;
  static constexpr TemplatedTypeKind ANY_ARRAY = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ARRAY;
  static constexpr TemplatedTypeKind ANY_TABLE = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TABLE;
  static inline bool TemplatedTypeKind_IsValid(int value) {
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_IsValid(value);
  }
  static constexpr TemplatedTypeKind TemplatedTypeKind_MIN = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MIN;
  static constexpr TemplatedTypeKind TemplatedTypeKind_MAX = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MAX;
  static constexpr int TemplatedTypeKind_ARRAYSIZE = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TemplatedTypeKind_descriptor() {
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor();
  }
  template <typename T>
  static inline const std::string& TemplatedTypeKind_Name(T value) {
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Name(value);
  }
  static inline bool TemplatedTypeKind_Parse(absl::string_view name, TemplatedTypeKind* value) {
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTTemplatedParameterTypeEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTTemplatedParameterTypeEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTSymbolQuantifierEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTSymbolQuantifierEnums) */ {
 public:
  inline ASTSymbolQuantifierEnums() : ASTSymbolQuantifierEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTSymbolQuantifierEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTSymbolQuantifierEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTSymbolQuantifierEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTSymbolQuantifierEnums(const ASTSymbolQuantifierEnums& from) : ASTSymbolQuantifierEnums(nullptr, from) {}
  inline ASTSymbolQuantifierEnums(ASTSymbolQuantifierEnums&& from) noexcept
      : ASTSymbolQuantifierEnums(nullptr, std::move(from)) {}
  inline ASTSymbolQuantifierEnums& operator=(const ASTSymbolQuantifierEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTSymbolQuantifierEnums& operator=(ASTSymbolQuantifierEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTSymbolQuantifierEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTSymbolQuantifierEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSymbolQuantifierEnums*>(
        &_ASTSymbolQuantifierEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(ASTSymbolQuantifierEnums& a, ASTSymbolQuantifierEnums& b) { a.Swap(&b); }
  inline void Swap(ASTSymbolQuantifierEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTSymbolQuantifierEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTSymbolQuantifierEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTSymbolQuantifierEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTSymbolQuantifierEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTSymbolQuantifierEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTSymbolQuantifierEnums"; }

 protected:
  explicit ASTSymbolQuantifierEnums(::google::protobuf::Arena* arena);
  ASTSymbolQuantifierEnums(::google::protobuf::Arena* arena, const ASTSymbolQuantifierEnums& from);
  ASTSymbolQuantifierEnums(::google::protobuf::Arena* arena, ASTSymbolQuantifierEnums&& from) noexcept
      : ASTSymbolQuantifierEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Symbol = ASTSymbolQuantifierEnums_Symbol;
  static constexpr Symbol SYMBOL_UNSPECIFIED = ASTSymbolQuantifierEnums_Symbol_SYMBOL_UNSPECIFIED;
  static constexpr Symbol QUESTION_MARK = ASTSymbolQuantifierEnums_Symbol_QUESTION_MARK;
  static constexpr Symbol PLUS = ASTSymbolQuantifierEnums_Symbol_PLUS;
  static constexpr Symbol STAR = ASTSymbolQuantifierEnums_Symbol_STAR;
  static inline bool Symbol_IsValid(int value) {
    return ASTSymbolQuantifierEnums_Symbol_IsValid(value);
  }
  static constexpr Symbol Symbol_MIN = ASTSymbolQuantifierEnums_Symbol_Symbol_MIN;
  static constexpr Symbol Symbol_MAX = ASTSymbolQuantifierEnums_Symbol_Symbol_MAX;
  static constexpr int Symbol_ARRAYSIZE = ASTSymbolQuantifierEnums_Symbol_Symbol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Symbol_descriptor() {
    return ASTSymbolQuantifierEnums_Symbol_descriptor();
  }
  template <typename T>
  static inline const std::string& Symbol_Name(T value) {
    return ASTSymbolQuantifierEnums_Symbol_Name(value);
  }
  static inline bool Symbol_Parse(absl::string_view name, Symbol* value) {
    return ASTSymbolQuantifierEnums_Symbol_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTSymbolQuantifierEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTSymbolQuantifierEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTSpannerInterleaveClauseEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTSpannerInterleaveClauseEnums) */ {
 public:
  inline ASTSpannerInterleaveClauseEnums() : ASTSpannerInterleaveClauseEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTSpannerInterleaveClauseEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTSpannerInterleaveClauseEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTSpannerInterleaveClauseEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTSpannerInterleaveClauseEnums(const ASTSpannerInterleaveClauseEnums& from) : ASTSpannerInterleaveClauseEnums(nullptr, from) {}
  inline ASTSpannerInterleaveClauseEnums(ASTSpannerInterleaveClauseEnums&& from) noexcept
      : ASTSpannerInterleaveClauseEnums(nullptr, std::move(from)) {}
  inline ASTSpannerInterleaveClauseEnums& operator=(const ASTSpannerInterleaveClauseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTSpannerInterleaveClauseEnums& operator=(ASTSpannerInterleaveClauseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTSpannerInterleaveClauseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTSpannerInterleaveClauseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSpannerInterleaveClauseEnums*>(
        &_ASTSpannerInterleaveClauseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(ASTSpannerInterleaveClauseEnums& a, ASTSpannerInterleaveClauseEnums& b) { a.Swap(&b); }
  inline void Swap(ASTSpannerInterleaveClauseEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTSpannerInterleaveClauseEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTSpannerInterleaveClauseEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTSpannerInterleaveClauseEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTSpannerInterleaveClauseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTSpannerInterleaveClauseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTSpannerInterleaveClauseEnums"; }

 protected:
  explicit ASTSpannerInterleaveClauseEnums(::google::protobuf::Arena* arena);
  ASTSpannerInterleaveClauseEnums(::google::protobuf::Arena* arena, const ASTSpannerInterleaveClauseEnums& from);
  ASTSpannerInterleaveClauseEnums(::google::protobuf::Arena* arena, ASTSpannerInterleaveClauseEnums&& from) noexcept
      : ASTSpannerInterleaveClauseEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = ASTSpannerInterleaveClauseEnums_Type;
  static constexpr Type NOT_SET = ASTSpannerInterleaveClauseEnums_Type_NOT_SET;
  static constexpr Type IN = ASTSpannerInterleaveClauseEnums_Type_IN;
  static constexpr Type IN_PARENT = ASTSpannerInterleaveClauseEnums_Type_IN_PARENT;
  static inline bool Type_IsValid(int value) {
    return ASTSpannerInterleaveClauseEnums_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = ASTSpannerInterleaveClauseEnums_Type_Type_MIN;
  static constexpr Type Type_MAX = ASTSpannerInterleaveClauseEnums_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = ASTSpannerInterleaveClauseEnums_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return ASTSpannerInterleaveClauseEnums_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return ASTSpannerInterleaveClauseEnums_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return ASTSpannerInterleaveClauseEnums_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTSpannerInterleaveClauseEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTSpannerInterleaveClauseEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTSetOperationEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTSetOperationEnums) */ {
 public:
  inline ASTSetOperationEnums() : ASTSetOperationEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTSetOperationEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTSetOperationEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTSetOperationEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTSetOperationEnums(const ASTSetOperationEnums& from) : ASTSetOperationEnums(nullptr, from) {}
  inline ASTSetOperationEnums(ASTSetOperationEnums&& from) noexcept
      : ASTSetOperationEnums(nullptr, std::move(from)) {}
  inline ASTSetOperationEnums& operator=(const ASTSetOperationEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTSetOperationEnums& operator=(ASTSetOperationEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTSetOperationEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTSetOperationEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSetOperationEnums*>(
        &_ASTSetOperationEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ASTSetOperationEnums& a, ASTSetOperationEnums& b) { a.Swap(&b); }
  inline void Swap(ASTSetOperationEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTSetOperationEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTSetOperationEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTSetOperationEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTSetOperationEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTSetOperationEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTSetOperationEnums"; }

 protected:
  explicit ASTSetOperationEnums(::google::protobuf::Arena* arena);
  ASTSetOperationEnums(::google::protobuf::Arena* arena, const ASTSetOperationEnums& from);
  ASTSetOperationEnums(::google::protobuf::Arena* arena, ASTSetOperationEnums&& from) noexcept
      : ASTSetOperationEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using OperationType = ASTSetOperationEnums_OperationType;
  static constexpr OperationType NOT_SET = ASTSetOperationEnums_OperationType_NOT_SET;
  static constexpr OperationType UNION = ASTSetOperationEnums_OperationType_UNION;
  static constexpr OperationType EXCEPT = ASTSetOperationEnums_OperationType_EXCEPT;
  static constexpr OperationType INTERSECT = ASTSetOperationEnums_OperationType_INTERSECT;
  static inline bool OperationType_IsValid(int value) {
    return ASTSetOperationEnums_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN = ASTSetOperationEnums_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX = ASTSetOperationEnums_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE = ASTSetOperationEnums_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OperationType_descriptor() {
    return ASTSetOperationEnums_OperationType_descriptor();
  }
  template <typename T>
  static inline const std::string& OperationType_Name(T value) {
    return ASTSetOperationEnums_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(absl::string_view name, OperationType* value) {
    return ASTSetOperationEnums_OperationType_Parse(name, value);
  }
  using AllOrDistinct = ASTSetOperationEnums_AllOrDistinct;
  static constexpr AllOrDistinct ALL_OR_DISTINCT_NOT_SET = ASTSetOperationEnums_AllOrDistinct_ALL_OR_DISTINCT_NOT_SET;
  static constexpr AllOrDistinct ALL = ASTSetOperationEnums_AllOrDistinct_ALL;
  static constexpr AllOrDistinct DISTINCT = ASTSetOperationEnums_AllOrDistinct_DISTINCT;
  static inline bool AllOrDistinct_IsValid(int value) {
    return ASTSetOperationEnums_AllOrDistinct_IsValid(value);
  }
  static constexpr AllOrDistinct AllOrDistinct_MIN = ASTSetOperationEnums_AllOrDistinct_AllOrDistinct_MIN;
  static constexpr AllOrDistinct AllOrDistinct_MAX = ASTSetOperationEnums_AllOrDistinct_AllOrDistinct_MAX;
  static constexpr int AllOrDistinct_ARRAYSIZE = ASTSetOperationEnums_AllOrDistinct_AllOrDistinct_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AllOrDistinct_descriptor() {
    return ASTSetOperationEnums_AllOrDistinct_descriptor();
  }
  template <typename T>
  static inline const std::string& AllOrDistinct_Name(T value) {
    return ASTSetOperationEnums_AllOrDistinct_Name(value);
  }
  static inline bool AllOrDistinct_Parse(absl::string_view name, AllOrDistinct* value) {
    return ASTSetOperationEnums_AllOrDistinct_Parse(name, value);
  }
  using ColumnMatchMode = ASTSetOperationEnums_ColumnMatchMode;
  static constexpr ColumnMatchMode BY_POSITION = ASTSetOperationEnums_ColumnMatchMode_BY_POSITION;
  static constexpr ColumnMatchMode CORRESPONDING = ASTSetOperationEnums_ColumnMatchMode_CORRESPONDING;
  static constexpr ColumnMatchMode CORRESPONDING_BY = ASTSetOperationEnums_ColumnMatchMode_CORRESPONDING_BY;
  static constexpr ColumnMatchMode BY_NAME = ASTSetOperationEnums_ColumnMatchMode_BY_NAME;
  static constexpr ColumnMatchMode BY_NAME_ON = ASTSetOperationEnums_ColumnMatchMode_BY_NAME_ON;
  static inline bool ColumnMatchMode_IsValid(int value) {
    return ASTSetOperationEnums_ColumnMatchMode_IsValid(value);
  }
  static constexpr ColumnMatchMode ColumnMatchMode_MIN = ASTSetOperationEnums_ColumnMatchMode_ColumnMatchMode_MIN;
  static constexpr ColumnMatchMode ColumnMatchMode_MAX = ASTSetOperationEnums_ColumnMatchMode_ColumnMatchMode_MAX;
  static constexpr int ColumnMatchMode_ARRAYSIZE = ASTSetOperationEnums_ColumnMatchMode_ColumnMatchMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ColumnMatchMode_descriptor() {
    return ASTSetOperationEnums_ColumnMatchMode_descriptor();
  }
  template <typename T>
  static inline const std::string& ColumnMatchMode_Name(T value) {
    return ASTSetOperationEnums_ColumnMatchMode_Name(value);
  }
  static inline bool ColumnMatchMode_Parse(absl::string_view name, ColumnMatchMode* value) {
    return ASTSetOperationEnums_ColumnMatchMode_Parse(name, value);
  }
  using ColumnPropagationMode = ASTSetOperationEnums_ColumnPropagationMode;
  static constexpr ColumnPropagationMode STRICT = ASTSetOperationEnums_ColumnPropagationMode_STRICT;
  static constexpr ColumnPropagationMode INNER = ASTSetOperationEnums_ColumnPropagationMode_INNER;
  static constexpr ColumnPropagationMode LEFT = ASTSetOperationEnums_ColumnPropagationMode_LEFT;
  static constexpr ColumnPropagationMode FULL = ASTSetOperationEnums_ColumnPropagationMode_FULL;
  static inline bool ColumnPropagationMode_IsValid(int value) {
    return ASTSetOperationEnums_ColumnPropagationMode_IsValid(value);
  }
  static constexpr ColumnPropagationMode ColumnPropagationMode_MIN = ASTSetOperationEnums_ColumnPropagationMode_ColumnPropagationMode_MIN;
  static constexpr ColumnPropagationMode ColumnPropagationMode_MAX = ASTSetOperationEnums_ColumnPropagationMode_ColumnPropagationMode_MAX;
  static constexpr int ColumnPropagationMode_ARRAYSIZE = ASTSetOperationEnums_ColumnPropagationMode_ColumnPropagationMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ColumnPropagationMode_descriptor() {
    return ASTSetOperationEnums_ColumnPropagationMode_descriptor();
  }
  template <typename T>
  static inline const std::string& ColumnPropagationMode_Name(T value) {
    return ASTSetOperationEnums_ColumnPropagationMode_Name(value);
  }
  static inline bool ColumnPropagationMode_Parse(absl::string_view name, ColumnPropagationMode* value) {
    return ASTSetOperationEnums_ColumnPropagationMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTSetOperationEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTSetOperationEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTSelectAsEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTSelectAsEnums) */ {
 public:
  inline ASTSelectAsEnums() : ASTSelectAsEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTSelectAsEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTSelectAsEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTSelectAsEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTSelectAsEnums(const ASTSelectAsEnums& from) : ASTSelectAsEnums(nullptr, from) {}
  inline ASTSelectAsEnums(ASTSelectAsEnums&& from) noexcept
      : ASTSelectAsEnums(nullptr, std::move(from)) {}
  inline ASTSelectAsEnums& operator=(const ASTSelectAsEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTSelectAsEnums& operator=(ASTSelectAsEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTSelectAsEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTSelectAsEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSelectAsEnums*>(
        &_ASTSelectAsEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ASTSelectAsEnums& a, ASTSelectAsEnums& b) { a.Swap(&b); }
  inline void Swap(ASTSelectAsEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTSelectAsEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTSelectAsEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTSelectAsEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTSelectAsEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTSelectAsEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTSelectAsEnums"; }

 protected:
  explicit ASTSelectAsEnums(::google::protobuf::Arena* arena);
  ASTSelectAsEnums(::google::protobuf::Arena* arena, const ASTSelectAsEnums& from);
  ASTSelectAsEnums(::google::protobuf::Arena* arena, ASTSelectAsEnums&& from) noexcept
      : ASTSelectAsEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using AsMode = ASTSelectAsEnums_AsMode;
  static constexpr AsMode NOT_SET = ASTSelectAsEnums_AsMode_NOT_SET;
  static constexpr AsMode STRUCT = ASTSelectAsEnums_AsMode_STRUCT;
  static constexpr AsMode VALUE = ASTSelectAsEnums_AsMode_VALUE;
  static constexpr AsMode TYPE_NAME = ASTSelectAsEnums_AsMode_TYPE_NAME;
  static inline bool AsMode_IsValid(int value) {
    return ASTSelectAsEnums_AsMode_IsValid(value);
  }
  static constexpr AsMode AsMode_MIN = ASTSelectAsEnums_AsMode_AsMode_MIN;
  static constexpr AsMode AsMode_MAX = ASTSelectAsEnums_AsMode_AsMode_MAX;
  static constexpr int AsMode_ARRAYSIZE = ASTSelectAsEnums_AsMode_AsMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AsMode_descriptor() {
    return ASTSelectAsEnums_AsMode_descriptor();
  }
  template <typename T>
  static inline const std::string& AsMode_Name(T value) {
    return ASTSelectAsEnums_AsMode_Name(value);
  }
  static inline bool AsMode_Parse(absl::string_view name, AsMode* value) {
    return ASTSelectAsEnums_AsMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTSelectAsEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTSelectAsEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTSampleSizeEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTSampleSizeEnums) */ {
 public:
  inline ASTSampleSizeEnums() : ASTSampleSizeEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTSampleSizeEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTSampleSizeEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTSampleSizeEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTSampleSizeEnums(const ASTSampleSizeEnums& from) : ASTSampleSizeEnums(nullptr, from) {}
  inline ASTSampleSizeEnums(ASTSampleSizeEnums&& from) noexcept
      : ASTSampleSizeEnums(nullptr, std::move(from)) {}
  inline ASTSampleSizeEnums& operator=(const ASTSampleSizeEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTSampleSizeEnums& operator=(ASTSampleSizeEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTSampleSizeEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTSampleSizeEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSampleSizeEnums*>(
        &_ASTSampleSizeEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(ASTSampleSizeEnums& a, ASTSampleSizeEnums& b) { a.Swap(&b); }
  inline void Swap(ASTSampleSizeEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTSampleSizeEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTSampleSizeEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTSampleSizeEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTSampleSizeEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTSampleSizeEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTSampleSizeEnums"; }

 protected:
  explicit ASTSampleSizeEnums(::google::protobuf::Arena* arena);
  ASTSampleSizeEnums(::google::protobuf::Arena* arena, const ASTSampleSizeEnums& from);
  ASTSampleSizeEnums(::google::protobuf::Arena* arena, ASTSampleSizeEnums&& from) noexcept
      : ASTSampleSizeEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Unit = ASTSampleSizeEnums_Unit;
  static constexpr Unit NOT_SET = ASTSampleSizeEnums_Unit_NOT_SET;
  static constexpr Unit ROWS = ASTSampleSizeEnums_Unit_ROWS;
  static constexpr Unit PERCENT = ASTSampleSizeEnums_Unit_PERCENT;
  static inline bool Unit_IsValid(int value) {
    return ASTSampleSizeEnums_Unit_IsValid(value);
  }
  static constexpr Unit Unit_MIN = ASTSampleSizeEnums_Unit_Unit_MIN;
  static constexpr Unit Unit_MAX = ASTSampleSizeEnums_Unit_Unit_MAX;
  static constexpr int Unit_ARRAYSIZE = ASTSampleSizeEnums_Unit_Unit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Unit_descriptor() {
    return ASTSampleSizeEnums_Unit_descriptor();
  }
  template <typename T>
  static inline const std::string& Unit_Name(T value) {
    return ASTSampleSizeEnums_Unit_Name(value);
  }
  static inline bool Unit_Parse(absl::string_view name, Unit* value) {
    return ASTSampleSizeEnums_Unit_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTSampleSizeEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTSampleSizeEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTRowPatternOperationEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTRowPatternOperationEnums) */ {
 public:
  inline ASTRowPatternOperationEnums() : ASTRowPatternOperationEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTRowPatternOperationEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTRowPatternOperationEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTRowPatternOperationEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTRowPatternOperationEnums(const ASTRowPatternOperationEnums& from) : ASTRowPatternOperationEnums(nullptr, from) {}
  inline ASTRowPatternOperationEnums(ASTRowPatternOperationEnums&& from) noexcept
      : ASTRowPatternOperationEnums(nullptr, std::move(from)) {}
  inline ASTRowPatternOperationEnums& operator=(const ASTRowPatternOperationEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTRowPatternOperationEnums& operator=(ASTRowPatternOperationEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTRowPatternOperationEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTRowPatternOperationEnums* internal_default_instance() {
    return reinterpret_cast<const ASTRowPatternOperationEnums*>(
        &_ASTRowPatternOperationEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(ASTRowPatternOperationEnums& a, ASTRowPatternOperationEnums& b) { a.Swap(&b); }
  inline void Swap(ASTRowPatternOperationEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTRowPatternOperationEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTRowPatternOperationEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTRowPatternOperationEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTRowPatternOperationEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTRowPatternOperationEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTRowPatternOperationEnums"; }

 protected:
  explicit ASTRowPatternOperationEnums(::google::protobuf::Arena* arena);
  ASTRowPatternOperationEnums(::google::protobuf::Arena* arena, const ASTRowPatternOperationEnums& from);
  ASTRowPatternOperationEnums(::google::protobuf::Arena* arena, ASTRowPatternOperationEnums&& from) noexcept
      : ASTRowPatternOperationEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using OperationType = ASTRowPatternOperationEnums_OperationType;
  static constexpr OperationType OPERATION_TYPE_UNSPECIFIED = ASTRowPatternOperationEnums_OperationType_OPERATION_TYPE_UNSPECIFIED;
  static constexpr OperationType CONCAT = ASTRowPatternOperationEnums_OperationType_CONCAT;
  static constexpr OperationType ALTERNATE = ASTRowPatternOperationEnums_OperationType_ALTERNATE;
  static constexpr OperationType PERMUTE = ASTRowPatternOperationEnums_OperationType_PERMUTE;
  static constexpr OperationType EXCLUDE = ASTRowPatternOperationEnums_OperationType_EXCLUDE;
  static inline bool OperationType_IsValid(int value) {
    return ASTRowPatternOperationEnums_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN = ASTRowPatternOperationEnums_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX = ASTRowPatternOperationEnums_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE = ASTRowPatternOperationEnums_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OperationType_descriptor() {
    return ASTRowPatternOperationEnums_OperationType_descriptor();
  }
  template <typename T>
  static inline const std::string& OperationType_Name(T value) {
    return ASTRowPatternOperationEnums_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(absl::string_view name, OperationType* value) {
    return ASTRowPatternOperationEnums_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTRowPatternOperationEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTRowPatternOperationEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTRowPatternAnchorEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTRowPatternAnchorEnums) */ {
 public:
  inline ASTRowPatternAnchorEnums() : ASTRowPatternAnchorEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTRowPatternAnchorEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTRowPatternAnchorEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTRowPatternAnchorEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTRowPatternAnchorEnums(const ASTRowPatternAnchorEnums& from) : ASTRowPatternAnchorEnums(nullptr, from) {}
  inline ASTRowPatternAnchorEnums(ASTRowPatternAnchorEnums&& from) noexcept
      : ASTRowPatternAnchorEnums(nullptr, std::move(from)) {}
  inline ASTRowPatternAnchorEnums& operator=(const ASTRowPatternAnchorEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTRowPatternAnchorEnums& operator=(ASTRowPatternAnchorEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTRowPatternAnchorEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTRowPatternAnchorEnums* internal_default_instance() {
    return reinterpret_cast<const ASTRowPatternAnchorEnums*>(
        &_ASTRowPatternAnchorEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(ASTRowPatternAnchorEnums& a, ASTRowPatternAnchorEnums& b) { a.Swap(&b); }
  inline void Swap(ASTRowPatternAnchorEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTRowPatternAnchorEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTRowPatternAnchorEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTRowPatternAnchorEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTRowPatternAnchorEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTRowPatternAnchorEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTRowPatternAnchorEnums"; }

 protected:
  explicit ASTRowPatternAnchorEnums(::google::protobuf::Arena* arena);
  ASTRowPatternAnchorEnums(::google::protobuf::Arena* arena, const ASTRowPatternAnchorEnums& from);
  ASTRowPatternAnchorEnums(::google::protobuf::Arena* arena, ASTRowPatternAnchorEnums&& from) noexcept
      : ASTRowPatternAnchorEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Anchor = ASTRowPatternAnchorEnums_Anchor;
  static constexpr Anchor ANCHOR_UNSPECIFIED = ASTRowPatternAnchorEnums_Anchor_ANCHOR_UNSPECIFIED;
  static constexpr Anchor START = ASTRowPatternAnchorEnums_Anchor_START;
  static constexpr Anchor END = ASTRowPatternAnchorEnums_Anchor_END;
  static inline bool Anchor_IsValid(int value) {
    return ASTRowPatternAnchorEnums_Anchor_IsValid(value);
  }
  static constexpr Anchor Anchor_MIN = ASTRowPatternAnchorEnums_Anchor_Anchor_MIN;
  static constexpr Anchor Anchor_MAX = ASTRowPatternAnchorEnums_Anchor_Anchor_MAX;
  static constexpr int Anchor_ARRAYSIZE = ASTRowPatternAnchorEnums_Anchor_Anchor_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Anchor_descriptor() {
    return ASTRowPatternAnchorEnums_Anchor_descriptor();
  }
  template <typename T>
  static inline const std::string& Anchor_Name(T value) {
    return ASTRowPatternAnchorEnums_Anchor_Name(value);
  }
  static inline bool Anchor_Parse(absl::string_view name, Anchor* value) {
    return ASTRowPatternAnchorEnums_Anchor_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTRowPatternAnchorEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTRowPatternAnchorEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTOrderingExpressionEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTOrderingExpressionEnums) */ {
 public:
  inline ASTOrderingExpressionEnums() : ASTOrderingExpressionEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTOrderingExpressionEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTOrderingExpressionEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTOrderingExpressionEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTOrderingExpressionEnums(const ASTOrderingExpressionEnums& from) : ASTOrderingExpressionEnums(nullptr, from) {}
  inline ASTOrderingExpressionEnums(ASTOrderingExpressionEnums&& from) noexcept
      : ASTOrderingExpressionEnums(nullptr, std::move(from)) {}
  inline ASTOrderingExpressionEnums& operator=(const ASTOrderingExpressionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTOrderingExpressionEnums& operator=(ASTOrderingExpressionEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTOrderingExpressionEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTOrderingExpressionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTOrderingExpressionEnums*>(
        &_ASTOrderingExpressionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ASTOrderingExpressionEnums& a, ASTOrderingExpressionEnums& b) { a.Swap(&b); }
  inline void Swap(ASTOrderingExpressionEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTOrderingExpressionEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTOrderingExpressionEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTOrderingExpressionEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTOrderingExpressionEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTOrderingExpressionEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTOrderingExpressionEnums"; }

 protected:
  explicit ASTOrderingExpressionEnums(::google::protobuf::Arena* arena);
  ASTOrderingExpressionEnums(::google::protobuf::Arena* arena, const ASTOrderingExpressionEnums& from);
  ASTOrderingExpressionEnums(::google::protobuf::Arena* arena, ASTOrderingExpressionEnums&& from) noexcept
      : ASTOrderingExpressionEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using OrderingSpec = ASTOrderingExpressionEnums_OrderingSpec;
  static constexpr OrderingSpec NOT_SET = ASTOrderingExpressionEnums_OrderingSpec_NOT_SET;
  static constexpr OrderingSpec ASC = ASTOrderingExpressionEnums_OrderingSpec_ASC;
  static constexpr OrderingSpec DESC = ASTOrderingExpressionEnums_OrderingSpec_DESC;
  static constexpr OrderingSpec UNSPECIFIED = ASTOrderingExpressionEnums_OrderingSpec_UNSPECIFIED;
  static inline bool OrderingSpec_IsValid(int value) {
    return ASTOrderingExpressionEnums_OrderingSpec_IsValid(value);
  }
  static constexpr OrderingSpec OrderingSpec_MIN = ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MIN;
  static constexpr OrderingSpec OrderingSpec_MAX = ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MAX;
  static constexpr int OrderingSpec_ARRAYSIZE = ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OrderingSpec_descriptor() {
    return ASTOrderingExpressionEnums_OrderingSpec_descriptor();
  }
  template <typename T>
  static inline const std::string& OrderingSpec_Name(T value) {
    return ASTOrderingExpressionEnums_OrderingSpec_Name(value);
  }
  static inline bool OrderingSpec_Parse(absl::string_view name, OrderingSpec* value) {
    return ASTOrderingExpressionEnums_OrderingSpec_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTOrderingExpressionEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTOrderingExpressionEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTOptionsEntryEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTOptionsEntryEnums) */ {
 public:
  inline ASTOptionsEntryEnums() : ASTOptionsEntryEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTOptionsEntryEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTOptionsEntryEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTOptionsEntryEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTOptionsEntryEnums(const ASTOptionsEntryEnums& from) : ASTOptionsEntryEnums(nullptr, from) {}
  inline ASTOptionsEntryEnums(ASTOptionsEntryEnums&& from) noexcept
      : ASTOptionsEntryEnums(nullptr, std::move(from)) {}
  inline ASTOptionsEntryEnums& operator=(const ASTOptionsEntryEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTOptionsEntryEnums& operator=(ASTOptionsEntryEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTOptionsEntryEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTOptionsEntryEnums* internal_default_instance() {
    return reinterpret_cast<const ASTOptionsEntryEnums*>(
        &_ASTOptionsEntryEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ASTOptionsEntryEnums& a, ASTOptionsEntryEnums& b) { a.Swap(&b); }
  inline void Swap(ASTOptionsEntryEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTOptionsEntryEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTOptionsEntryEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTOptionsEntryEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTOptionsEntryEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTOptionsEntryEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTOptionsEntryEnums"; }

 protected:
  explicit ASTOptionsEntryEnums(::google::protobuf::Arena* arena);
  ASTOptionsEntryEnums(::google::protobuf::Arena* arena, const ASTOptionsEntryEnums& from);
  ASTOptionsEntryEnums(::google::protobuf::Arena* arena, ASTOptionsEntryEnums&& from) noexcept
      : ASTOptionsEntryEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using AssignmentOp = ASTOptionsEntryEnums_AssignmentOp;
  static constexpr AssignmentOp NOT_SET = ASTOptionsEntryEnums_AssignmentOp_NOT_SET;
  static constexpr AssignmentOp ASSIGN = ASTOptionsEntryEnums_AssignmentOp_ASSIGN;
  static constexpr AssignmentOp ADD_ASSIGN = ASTOptionsEntryEnums_AssignmentOp_ADD_ASSIGN;
  static constexpr AssignmentOp SUB_ASSIGN = ASTOptionsEntryEnums_AssignmentOp_SUB_ASSIGN;
  static inline bool AssignmentOp_IsValid(int value) {
    return ASTOptionsEntryEnums_AssignmentOp_IsValid(value);
  }
  static constexpr AssignmentOp AssignmentOp_MIN = ASTOptionsEntryEnums_AssignmentOp_AssignmentOp_MIN;
  static constexpr AssignmentOp AssignmentOp_MAX = ASTOptionsEntryEnums_AssignmentOp_AssignmentOp_MAX;
  static constexpr int AssignmentOp_ARRAYSIZE = ASTOptionsEntryEnums_AssignmentOp_AssignmentOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AssignmentOp_descriptor() {
    return ASTOptionsEntryEnums_AssignmentOp_descriptor();
  }
  template <typename T>
  static inline const std::string& AssignmentOp_Name(T value) {
    return ASTOptionsEntryEnums_AssignmentOp_Name(value);
  }
  static inline bool AssignmentOp_Parse(absl::string_view name, AssignmentOp* value) {
    return ASTOptionsEntryEnums_AssignmentOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTOptionsEntryEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTOptionsEntryEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTOnConflictClauseEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTOnConflictClauseEnums) */ {
 public:
  inline ASTOnConflictClauseEnums() : ASTOnConflictClauseEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTOnConflictClauseEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTOnConflictClauseEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTOnConflictClauseEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTOnConflictClauseEnums(const ASTOnConflictClauseEnums& from) : ASTOnConflictClauseEnums(nullptr, from) {}
  inline ASTOnConflictClauseEnums(ASTOnConflictClauseEnums&& from) noexcept
      : ASTOnConflictClauseEnums(nullptr, std::move(from)) {}
  inline ASTOnConflictClauseEnums& operator=(const ASTOnConflictClauseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTOnConflictClauseEnums& operator=(ASTOnConflictClauseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTOnConflictClauseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTOnConflictClauseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTOnConflictClauseEnums*>(
        &_ASTOnConflictClauseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(ASTOnConflictClauseEnums& a, ASTOnConflictClauseEnums& b) { a.Swap(&b); }
  inline void Swap(ASTOnConflictClauseEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTOnConflictClauseEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTOnConflictClauseEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTOnConflictClauseEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTOnConflictClauseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTOnConflictClauseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTOnConflictClauseEnums"; }

 protected:
  explicit ASTOnConflictClauseEnums(::google::protobuf::Arena* arena);
  ASTOnConflictClauseEnums(::google::protobuf::Arena* arena, const ASTOnConflictClauseEnums& from);
  ASTOnConflictClauseEnums(::google::protobuf::Arena* arena, ASTOnConflictClauseEnums&& from) noexcept
      : ASTOnConflictClauseEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ConflictAction = ASTOnConflictClauseEnums_ConflictAction;
  static constexpr ConflictAction NOT_SET = ASTOnConflictClauseEnums_ConflictAction_NOT_SET;
  static constexpr ConflictAction NOTHING = ASTOnConflictClauseEnums_ConflictAction_NOTHING;
  static constexpr ConflictAction UPDATE = ASTOnConflictClauseEnums_ConflictAction_UPDATE;
  static inline bool ConflictAction_IsValid(int value) {
    return ASTOnConflictClauseEnums_ConflictAction_IsValid(value);
  }
  static constexpr ConflictAction ConflictAction_MIN = ASTOnConflictClauseEnums_ConflictAction_ConflictAction_MIN;
  static constexpr ConflictAction ConflictAction_MAX = ASTOnConflictClauseEnums_ConflictAction_ConflictAction_MAX;
  static constexpr int ConflictAction_ARRAYSIZE = ASTOnConflictClauseEnums_ConflictAction_ConflictAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ConflictAction_descriptor() {
    return ASTOnConflictClauseEnums_ConflictAction_descriptor();
  }
  template <typename T>
  static inline const std::string& ConflictAction_Name(T value) {
    return ASTOnConflictClauseEnums_ConflictAction_Name(value);
  }
  static inline bool ConflictAction_Parse(absl::string_view name, ConflictAction* value) {
    return ASTOnConflictClauseEnums_ConflictAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTOnConflictClauseEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTOnConflictClauseEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTMergeWhenClauseEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTMergeWhenClauseEnums) */ {
 public:
  inline ASTMergeWhenClauseEnums() : ASTMergeWhenClauseEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTMergeWhenClauseEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTMergeWhenClauseEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTMergeWhenClauseEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTMergeWhenClauseEnums(const ASTMergeWhenClauseEnums& from) : ASTMergeWhenClauseEnums(nullptr, from) {}
  inline ASTMergeWhenClauseEnums(ASTMergeWhenClauseEnums&& from) noexcept
      : ASTMergeWhenClauseEnums(nullptr, std::move(from)) {}
  inline ASTMergeWhenClauseEnums& operator=(const ASTMergeWhenClauseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTMergeWhenClauseEnums& operator=(ASTMergeWhenClauseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTMergeWhenClauseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTMergeWhenClauseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTMergeWhenClauseEnums*>(
        &_ASTMergeWhenClauseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(ASTMergeWhenClauseEnums& a, ASTMergeWhenClauseEnums& b) { a.Swap(&b); }
  inline void Swap(ASTMergeWhenClauseEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTMergeWhenClauseEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTMergeWhenClauseEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTMergeWhenClauseEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTMergeWhenClauseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTMergeWhenClauseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTMergeWhenClauseEnums"; }

 protected:
  explicit ASTMergeWhenClauseEnums(::google::protobuf::Arena* arena);
  ASTMergeWhenClauseEnums(::google::protobuf::Arena* arena, const ASTMergeWhenClauseEnums& from);
  ASTMergeWhenClauseEnums(::google::protobuf::Arena* arena, ASTMergeWhenClauseEnums&& from) noexcept
      : ASTMergeWhenClauseEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MatchType = ASTMergeWhenClauseEnums_MatchType;
  static constexpr MatchType NOT_SET = ASTMergeWhenClauseEnums_MatchType_NOT_SET;
  static constexpr MatchType MATCHED = ASTMergeWhenClauseEnums_MatchType_MATCHED;
  static constexpr MatchType NOT_MATCHED_BY_SOURCE = ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_SOURCE;
  static constexpr MatchType NOT_MATCHED_BY_TARGET = ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_TARGET;
  static inline bool MatchType_IsValid(int value) {
    return ASTMergeWhenClauseEnums_MatchType_IsValid(value);
  }
  static constexpr MatchType MatchType_MIN = ASTMergeWhenClauseEnums_MatchType_MatchType_MIN;
  static constexpr MatchType MatchType_MAX = ASTMergeWhenClauseEnums_MatchType_MatchType_MAX;
  static constexpr int MatchType_ARRAYSIZE = ASTMergeWhenClauseEnums_MatchType_MatchType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MatchType_descriptor() {
    return ASTMergeWhenClauseEnums_MatchType_descriptor();
  }
  template <typename T>
  static inline const std::string& MatchType_Name(T value) {
    return ASTMergeWhenClauseEnums_MatchType_Name(value);
  }
  static inline bool MatchType_Parse(absl::string_view name, MatchType* value) {
    return ASTMergeWhenClauseEnums_MatchType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTMergeWhenClauseEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTMergeWhenClauseEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTMergeActionEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTMergeActionEnums) */ {
 public:
  inline ASTMergeActionEnums() : ASTMergeActionEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTMergeActionEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTMergeActionEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTMergeActionEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTMergeActionEnums(const ASTMergeActionEnums& from) : ASTMergeActionEnums(nullptr, from) {}
  inline ASTMergeActionEnums(ASTMergeActionEnums&& from) noexcept
      : ASTMergeActionEnums(nullptr, std::move(from)) {}
  inline ASTMergeActionEnums& operator=(const ASTMergeActionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTMergeActionEnums& operator=(ASTMergeActionEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTMergeActionEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTMergeActionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTMergeActionEnums*>(
        &_ASTMergeActionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(ASTMergeActionEnums& a, ASTMergeActionEnums& b) { a.Swap(&b); }
  inline void Swap(ASTMergeActionEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTMergeActionEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTMergeActionEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTMergeActionEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTMergeActionEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTMergeActionEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTMergeActionEnums"; }

 protected:
  explicit ASTMergeActionEnums(::google::protobuf::Arena* arena);
  ASTMergeActionEnums(::google::protobuf::Arena* arena, const ASTMergeActionEnums& from);
  ASTMergeActionEnums(::google::protobuf::Arena* arena, ASTMergeActionEnums&& from) noexcept
      : ASTMergeActionEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ActionType = ASTMergeActionEnums_ActionType;
  static constexpr ActionType NOT_SET = ASTMergeActionEnums_ActionType_NOT_SET;
  static constexpr ActionType INSERT = ASTMergeActionEnums_ActionType_INSERT;
  static constexpr ActionType UPDATE = ASTMergeActionEnums_ActionType_UPDATE;
  static constexpr ActionType DELETE = ASTMergeActionEnums_ActionType_DELETE;
  static inline bool ActionType_IsValid(int value) {
    return ASTMergeActionEnums_ActionType_IsValid(value);
  }
  static constexpr ActionType ActionType_MIN = ASTMergeActionEnums_ActionType_ActionType_MIN;
  static constexpr ActionType ActionType_MAX = ASTMergeActionEnums_ActionType_ActionType_MAX;
  static constexpr int ActionType_ARRAYSIZE = ASTMergeActionEnums_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ActionType_descriptor() {
    return ASTMergeActionEnums_ActionType_descriptor();
  }
  template <typename T>
  static inline const std::string& ActionType_Name(T value) {
    return ASTMergeActionEnums_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(absl::string_view name, ActionType* value) {
    return ASTMergeActionEnums_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTMergeActionEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTMergeActionEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTLockModeEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTLockModeEnums) */ {
 public:
  inline ASTLockModeEnums() : ASTLockModeEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTLockModeEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTLockModeEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTLockModeEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTLockModeEnums(const ASTLockModeEnums& from) : ASTLockModeEnums(nullptr, from) {}
  inline ASTLockModeEnums(ASTLockModeEnums&& from) noexcept
      : ASTLockModeEnums(nullptr, std::move(from)) {}
  inline ASTLockModeEnums& operator=(const ASTLockModeEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTLockModeEnums& operator=(ASTLockModeEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTLockModeEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTLockModeEnums* internal_default_instance() {
    return reinterpret_cast<const ASTLockModeEnums*>(
        &_ASTLockModeEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(ASTLockModeEnums& a, ASTLockModeEnums& b) { a.Swap(&b); }
  inline void Swap(ASTLockModeEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTLockModeEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTLockModeEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTLockModeEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTLockModeEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTLockModeEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTLockModeEnums"; }

 protected:
  explicit ASTLockModeEnums(::google::protobuf::Arena* arena);
  ASTLockModeEnums(::google::protobuf::Arena* arena, const ASTLockModeEnums& from);
  ASTLockModeEnums(::google::protobuf::Arena* arena, ASTLockModeEnums&& from) noexcept
      : ASTLockModeEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using LockStrengthSpec = ASTLockModeEnums_LockStrengthSpec;
  static constexpr LockStrengthSpec NOT_SET = ASTLockModeEnums_LockStrengthSpec_NOT_SET;
  static constexpr LockStrengthSpec UPDATE = ASTLockModeEnums_LockStrengthSpec_UPDATE;
  static inline bool LockStrengthSpec_IsValid(int value) {
    return ASTLockModeEnums_LockStrengthSpec_IsValid(value);
  }
  static constexpr LockStrengthSpec LockStrengthSpec_MIN = ASTLockModeEnums_LockStrengthSpec_LockStrengthSpec_MIN;
  static constexpr LockStrengthSpec LockStrengthSpec_MAX = ASTLockModeEnums_LockStrengthSpec_LockStrengthSpec_MAX;
  static constexpr int LockStrengthSpec_ARRAYSIZE = ASTLockModeEnums_LockStrengthSpec_LockStrengthSpec_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LockStrengthSpec_descriptor() {
    return ASTLockModeEnums_LockStrengthSpec_descriptor();
  }
  template <typename T>
  static inline const std::string& LockStrengthSpec_Name(T value) {
    return ASTLockModeEnums_LockStrengthSpec_Name(value);
  }
  static inline bool LockStrengthSpec_Parse(absl::string_view name, LockStrengthSpec* value) {
    return ASTLockModeEnums_LockStrengthSpec_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTLockModeEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTLockModeEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTJoinEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTJoinEnums) */ {
 public:
  inline ASTJoinEnums() : ASTJoinEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTJoinEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTJoinEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTJoinEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTJoinEnums(const ASTJoinEnums& from) : ASTJoinEnums(nullptr, from) {}
  inline ASTJoinEnums(ASTJoinEnums&& from) noexcept
      : ASTJoinEnums(nullptr, std::move(from)) {}
  inline ASTJoinEnums& operator=(const ASTJoinEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTJoinEnums& operator=(ASTJoinEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTJoinEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTJoinEnums* internal_default_instance() {
    return reinterpret_cast<const ASTJoinEnums*>(
        &_ASTJoinEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ASTJoinEnums& a, ASTJoinEnums& b) { a.Swap(&b); }
  inline void Swap(ASTJoinEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTJoinEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTJoinEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTJoinEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTJoinEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTJoinEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTJoinEnums"; }

 protected:
  explicit ASTJoinEnums(::google::protobuf::Arena* arena);
  ASTJoinEnums(::google::protobuf::Arena* arena, const ASTJoinEnums& from);
  ASTJoinEnums(::google::protobuf::Arena* arena, ASTJoinEnums&& from) noexcept
      : ASTJoinEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using JoinType = ASTJoinEnums_JoinType;
  static constexpr JoinType DEFAULT_JOIN_TYPE = ASTJoinEnums_JoinType_DEFAULT_JOIN_TYPE;
  static constexpr JoinType COMMA = ASTJoinEnums_JoinType_COMMA;
  static constexpr JoinType CROSS = ASTJoinEnums_JoinType_CROSS;
  static constexpr JoinType FULL = ASTJoinEnums_JoinType_FULL;
  static constexpr JoinType INNER = ASTJoinEnums_JoinType_INNER;
  static constexpr JoinType LEFT = ASTJoinEnums_JoinType_LEFT;
  static constexpr JoinType RIGHT = ASTJoinEnums_JoinType_RIGHT;
  static inline bool JoinType_IsValid(int value) {
    return ASTJoinEnums_JoinType_IsValid(value);
  }
  static constexpr JoinType JoinType_MIN = ASTJoinEnums_JoinType_JoinType_MIN;
  static constexpr JoinType JoinType_MAX = ASTJoinEnums_JoinType_JoinType_MAX;
  static constexpr int JoinType_ARRAYSIZE = ASTJoinEnums_JoinType_JoinType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* JoinType_descriptor() {
    return ASTJoinEnums_JoinType_descriptor();
  }
  template <typename T>
  static inline const std::string& JoinType_Name(T value) {
    return ASTJoinEnums_JoinType_Name(value);
  }
  static inline bool JoinType_Parse(absl::string_view name, JoinType* value) {
    return ASTJoinEnums_JoinType_Parse(name, value);
  }
  using JoinHint = ASTJoinEnums_JoinHint;
  static constexpr JoinHint NO_JOIN_HINT = ASTJoinEnums_JoinHint_NO_JOIN_HINT;
  static constexpr JoinHint HASH = ASTJoinEnums_JoinHint_HASH;
  static constexpr JoinHint LOOKUP = ASTJoinEnums_JoinHint_LOOKUP;
  static inline bool JoinHint_IsValid(int value) {
    return ASTJoinEnums_JoinHint_IsValid(value);
  }
  static constexpr JoinHint JoinHint_MIN = ASTJoinEnums_JoinHint_JoinHint_MIN;
  static constexpr JoinHint JoinHint_MAX = ASTJoinEnums_JoinHint_JoinHint_MAX;
  static constexpr int JoinHint_ARRAYSIZE = ASTJoinEnums_JoinHint_JoinHint_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* JoinHint_descriptor() {
    return ASTJoinEnums_JoinHint_descriptor();
  }
  template <typename T>
  static inline const std::string& JoinHint_Name(T value) {
    return ASTJoinEnums_JoinHint_Name(value);
  }
  static inline bool JoinHint_Parse(absl::string_view name, JoinHint* value) {
    return ASTJoinEnums_JoinHint_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTJoinEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTJoinEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTInsertStatementEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTInsertStatementEnums) */ {
 public:
  inline ASTInsertStatementEnums() : ASTInsertStatementEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTInsertStatementEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTInsertStatementEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTInsertStatementEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTInsertStatementEnums(const ASTInsertStatementEnums& from) : ASTInsertStatementEnums(nullptr, from) {}
  inline ASTInsertStatementEnums(ASTInsertStatementEnums&& from) noexcept
      : ASTInsertStatementEnums(nullptr, std::move(from)) {}
  inline ASTInsertStatementEnums& operator=(const ASTInsertStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTInsertStatementEnums& operator=(ASTInsertStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTInsertStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTInsertStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTInsertStatementEnums*>(
        &_ASTInsertStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(ASTInsertStatementEnums& a, ASTInsertStatementEnums& b) { a.Swap(&b); }
  inline void Swap(ASTInsertStatementEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTInsertStatementEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTInsertStatementEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTInsertStatementEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTInsertStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTInsertStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTInsertStatementEnums"; }

 protected:
  explicit ASTInsertStatementEnums(::google::protobuf::Arena* arena);
  ASTInsertStatementEnums(::google::protobuf::Arena* arena, const ASTInsertStatementEnums& from);
  ASTInsertStatementEnums(::google::protobuf::Arena* arena, ASTInsertStatementEnums&& from) noexcept
      : ASTInsertStatementEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using InsertMode = ASTInsertStatementEnums_InsertMode;
  static constexpr InsertMode DEFAULT_MODE = ASTInsertStatementEnums_InsertMode_DEFAULT_MODE;
  static constexpr InsertMode REPLACE = ASTInsertStatementEnums_InsertMode_REPLACE;
  static constexpr InsertMode UPDATE = ASTInsertStatementEnums_InsertMode_UPDATE;
  static constexpr InsertMode IGNORE = ASTInsertStatementEnums_InsertMode_IGNORE;
  static inline bool InsertMode_IsValid(int value) {
    return ASTInsertStatementEnums_InsertMode_IsValid(value);
  }
  static constexpr InsertMode InsertMode_MIN = ASTInsertStatementEnums_InsertMode_InsertMode_MIN;
  static constexpr InsertMode InsertMode_MAX = ASTInsertStatementEnums_InsertMode_InsertMode_MAX;
  static constexpr int InsertMode_ARRAYSIZE = ASTInsertStatementEnums_InsertMode_InsertMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* InsertMode_descriptor() {
    return ASTInsertStatementEnums_InsertMode_descriptor();
  }
  template <typename T>
  static inline const std::string& InsertMode_Name(T value) {
    return ASTInsertStatementEnums_InsertMode_Name(value);
  }
  static inline bool InsertMode_Parse(absl::string_view name, InsertMode* value) {
    return ASTInsertStatementEnums_InsertMode_Parse(name, value);
  }
  using ParseProgress = ASTInsertStatementEnums_ParseProgress;
  static constexpr ParseProgress kInitial = ASTInsertStatementEnums_ParseProgress_kInitial;
  static constexpr ParseProgress kSeenOrIgnoreReplaceUpdate = ASTInsertStatementEnums_ParseProgress_kSeenOrIgnoreReplaceUpdate;
  static constexpr ParseProgress kSeenTargetPath = ASTInsertStatementEnums_ParseProgress_kSeenTargetPath;
  static constexpr ParseProgress kSeenColumnList = ASTInsertStatementEnums_ParseProgress_kSeenColumnList;
  static constexpr ParseProgress kSeenValuesList = ASTInsertStatementEnums_ParseProgress_kSeenValuesList;
  static inline bool ParseProgress_IsValid(int value) {
    return ASTInsertStatementEnums_ParseProgress_IsValid(value);
  }
  static constexpr ParseProgress ParseProgress_MIN = ASTInsertStatementEnums_ParseProgress_ParseProgress_MIN;
  static constexpr ParseProgress ParseProgress_MAX = ASTInsertStatementEnums_ParseProgress_ParseProgress_MAX;
  static constexpr int ParseProgress_ARRAYSIZE = ASTInsertStatementEnums_ParseProgress_ParseProgress_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ParseProgress_descriptor() {
    return ASTInsertStatementEnums_ParseProgress_descriptor();
  }
  template <typename T>
  static inline const std::string& ParseProgress_Name(T value) {
    return ASTInsertStatementEnums_ParseProgress_Name(value);
  }
  static inline bool ParseProgress_Parse(absl::string_view name, ParseProgress* value) {
    return ASTInsertStatementEnums_ParseProgress_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTInsertStatementEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTInsertStatementEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTImportStatementEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTImportStatementEnums) */ {
 public:
  inline ASTImportStatementEnums() : ASTImportStatementEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTImportStatementEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTImportStatementEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTImportStatementEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTImportStatementEnums(const ASTImportStatementEnums& from) : ASTImportStatementEnums(nullptr, from) {}
  inline ASTImportStatementEnums(ASTImportStatementEnums&& from) noexcept
      : ASTImportStatementEnums(nullptr, std::move(from)) {}
  inline ASTImportStatementEnums& operator=(const ASTImportStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTImportStatementEnums& operator=(ASTImportStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTImportStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTImportStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTImportStatementEnums*>(
        &_ASTImportStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ASTImportStatementEnums& a, ASTImportStatementEnums& b) { a.Swap(&b); }
  inline void Swap(ASTImportStatementEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTImportStatementEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTImportStatementEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTImportStatementEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTImportStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTImportStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTImportStatementEnums"; }

 protected:
  explicit ASTImportStatementEnums(::google::protobuf::Arena* arena);
  ASTImportStatementEnums(::google::protobuf::Arena* arena, const ASTImportStatementEnums& from);
  ASTImportStatementEnums(::google::protobuf::Arena* arena, ASTImportStatementEnums&& from) noexcept
      : ASTImportStatementEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ImportKind = ASTImportStatementEnums_ImportKind;
  static constexpr ImportKind MODULE = ASTImportStatementEnums_ImportKind_MODULE;
  static constexpr ImportKind PROTO = ASTImportStatementEnums_ImportKind_PROTO;
  static inline bool ImportKind_IsValid(int value) {
    return ASTImportStatementEnums_ImportKind_IsValid(value);
  }
  static constexpr ImportKind ImportKind_MIN = ASTImportStatementEnums_ImportKind_ImportKind_MIN;
  static constexpr ImportKind ImportKind_MAX = ASTImportStatementEnums_ImportKind_ImportKind_MAX;
  static constexpr int ImportKind_ARRAYSIZE = ASTImportStatementEnums_ImportKind_ImportKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ImportKind_descriptor() {
    return ASTImportStatementEnums_ImportKind_descriptor();
  }
  template <typename T>
  static inline const std::string& ImportKind_Name(T value) {
    return ASTImportStatementEnums_ImportKind_Name(value);
  }
  static inline bool ImportKind_Parse(absl::string_view name, ImportKind* value) {
    return ASTImportStatementEnums_ImportKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTImportStatementEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTImportStatementEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTHavingModifierEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTHavingModifierEnums) */ {
 public:
  inline ASTHavingModifierEnums() : ASTHavingModifierEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTHavingModifierEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTHavingModifierEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTHavingModifierEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTHavingModifierEnums(const ASTHavingModifierEnums& from) : ASTHavingModifierEnums(nullptr, from) {}
  inline ASTHavingModifierEnums(ASTHavingModifierEnums&& from) noexcept
      : ASTHavingModifierEnums(nullptr, std::move(from)) {}
  inline ASTHavingModifierEnums& operator=(const ASTHavingModifierEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTHavingModifierEnums& operator=(ASTHavingModifierEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTHavingModifierEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTHavingModifierEnums* internal_default_instance() {
    return reinterpret_cast<const ASTHavingModifierEnums*>(
        &_ASTHavingModifierEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ASTHavingModifierEnums& a, ASTHavingModifierEnums& b) { a.Swap(&b); }
  inline void Swap(ASTHavingModifierEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTHavingModifierEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTHavingModifierEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTHavingModifierEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTHavingModifierEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTHavingModifierEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTHavingModifierEnums"; }

 protected:
  explicit ASTHavingModifierEnums(::google::protobuf::Arena* arena);
  ASTHavingModifierEnums(::google::protobuf::Arena* arena, const ASTHavingModifierEnums& from);
  ASTHavingModifierEnums(::google::protobuf::Arena* arena, ASTHavingModifierEnums&& from) noexcept
      : ASTHavingModifierEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ModifierKind = ASTHavingModifierEnums_ModifierKind;
  static constexpr ModifierKind NOT_SET = ASTHavingModifierEnums_ModifierKind_NOT_SET;
  static constexpr ModifierKind MIN = ASTHavingModifierEnums_ModifierKind_MIN;
  static constexpr ModifierKind MAX = ASTHavingModifierEnums_ModifierKind_MAX;
  static inline bool ModifierKind_IsValid(int value) {
    return ASTHavingModifierEnums_ModifierKind_IsValid(value);
  }
  static constexpr ModifierKind ModifierKind_MIN = ASTHavingModifierEnums_ModifierKind_ModifierKind_MIN;
  static constexpr ModifierKind ModifierKind_MAX = ASTHavingModifierEnums_ModifierKind_ModifierKind_MAX;
  static constexpr int ModifierKind_ARRAYSIZE = ASTHavingModifierEnums_ModifierKind_ModifierKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ModifierKind_descriptor() {
    return ASTHavingModifierEnums_ModifierKind_descriptor();
  }
  template <typename T>
  static inline const std::string& ModifierKind_Name(T value) {
    return ASTHavingModifierEnums_ModifierKind_Name(value);
  }
  static inline bool ModifierKind_Parse(absl::string_view name, ModifierKind* value) {
    return ASTHavingModifierEnums_ModifierKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTHavingModifierEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTHavingModifierEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTGraphPathSearchPrefixEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTGraphPathSearchPrefixEnums) */ {
 public:
  inline ASTGraphPathSearchPrefixEnums() : ASTGraphPathSearchPrefixEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTGraphPathSearchPrefixEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTGraphPathSearchPrefixEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTGraphPathSearchPrefixEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTGraphPathSearchPrefixEnums(const ASTGraphPathSearchPrefixEnums& from) : ASTGraphPathSearchPrefixEnums(nullptr, from) {}
  inline ASTGraphPathSearchPrefixEnums(ASTGraphPathSearchPrefixEnums&& from) noexcept
      : ASTGraphPathSearchPrefixEnums(nullptr, std::move(from)) {}
  inline ASTGraphPathSearchPrefixEnums& operator=(const ASTGraphPathSearchPrefixEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTGraphPathSearchPrefixEnums& operator=(ASTGraphPathSearchPrefixEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTGraphPathSearchPrefixEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTGraphPathSearchPrefixEnums* internal_default_instance() {
    return reinterpret_cast<const ASTGraphPathSearchPrefixEnums*>(
        &_ASTGraphPathSearchPrefixEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(ASTGraphPathSearchPrefixEnums& a, ASTGraphPathSearchPrefixEnums& b) { a.Swap(&b); }
  inline void Swap(ASTGraphPathSearchPrefixEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTGraphPathSearchPrefixEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTGraphPathSearchPrefixEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTGraphPathSearchPrefixEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTGraphPathSearchPrefixEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTGraphPathSearchPrefixEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTGraphPathSearchPrefixEnums"; }

 protected:
  explicit ASTGraphPathSearchPrefixEnums(::google::protobuf::Arena* arena);
  ASTGraphPathSearchPrefixEnums(::google::protobuf::Arena* arena, const ASTGraphPathSearchPrefixEnums& from);
  ASTGraphPathSearchPrefixEnums(::google::protobuf::Arena* arena, ASTGraphPathSearchPrefixEnums&& from) noexcept
      : ASTGraphPathSearchPrefixEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using PathSearchPrefixType = ASTGraphPathSearchPrefixEnums_PathSearchPrefixType;
  static constexpr PathSearchPrefixType PATH_SEARCH_PREFIX_TYPE_UNSPECIFIED = ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_PATH_SEARCH_PREFIX_TYPE_UNSPECIFIED;
  static constexpr PathSearchPrefixType ANY = ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_ANY;
  static constexpr PathSearchPrefixType SHORTEST = ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_SHORTEST;
  static constexpr PathSearchPrefixType ALL = ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_ALL;
  static constexpr PathSearchPrefixType ALL_SHORTEST = ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_ALL_SHORTEST;
  static constexpr PathSearchPrefixType CHEAPEST = ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_CHEAPEST;
  static constexpr PathSearchPrefixType ALL_CHEAPEST = ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_ALL_CHEAPEST;
  static inline bool PathSearchPrefixType_IsValid(int value) {
    return ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_IsValid(value);
  }
  static constexpr PathSearchPrefixType PathSearchPrefixType_MIN = ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_PathSearchPrefixType_MIN;
  static constexpr PathSearchPrefixType PathSearchPrefixType_MAX = ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_PathSearchPrefixType_MAX;
  static constexpr int PathSearchPrefixType_ARRAYSIZE = ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_PathSearchPrefixType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PathSearchPrefixType_descriptor() {
    return ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_descriptor();
  }
  template <typename T>
  static inline const std::string& PathSearchPrefixType_Name(T value) {
    return ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_Name(value);
  }
  static inline bool PathSearchPrefixType_Parse(absl::string_view name, PathSearchPrefixType* value) {
    return ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTGraphPathSearchPrefixEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTGraphPathSearchPrefixEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTGraphPathModeEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTGraphPathModeEnums) */ {
 public:
  inline ASTGraphPathModeEnums() : ASTGraphPathModeEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTGraphPathModeEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTGraphPathModeEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTGraphPathModeEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTGraphPathModeEnums(const ASTGraphPathModeEnums& from) : ASTGraphPathModeEnums(nullptr, from) {}
  inline ASTGraphPathModeEnums(ASTGraphPathModeEnums&& from) noexcept
      : ASTGraphPathModeEnums(nullptr, std::move(from)) {}
  inline ASTGraphPathModeEnums& operator=(const ASTGraphPathModeEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTGraphPathModeEnums& operator=(ASTGraphPathModeEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTGraphPathModeEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTGraphPathModeEnums* internal_default_instance() {
    return reinterpret_cast<const ASTGraphPathModeEnums*>(
        &_ASTGraphPathModeEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(ASTGraphPathModeEnums& a, ASTGraphPathModeEnums& b) { a.Swap(&b); }
  inline void Swap(ASTGraphPathModeEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTGraphPathModeEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTGraphPathModeEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTGraphPathModeEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTGraphPathModeEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTGraphPathModeEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTGraphPathModeEnums"; }

 protected:
  explicit ASTGraphPathModeEnums(::google::protobuf::Arena* arena);
  ASTGraphPathModeEnums(::google::protobuf::Arena* arena, const ASTGraphPathModeEnums& from);
  ASTGraphPathModeEnums(::google::protobuf::Arena* arena, ASTGraphPathModeEnums&& from) noexcept
      : ASTGraphPathModeEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using PathMode = ASTGraphPathModeEnums_PathMode;
  static constexpr PathMode PATH_MODE_UNSPECIFIED = ASTGraphPathModeEnums_PathMode_PATH_MODE_UNSPECIFIED;
  static constexpr PathMode WALK = ASTGraphPathModeEnums_PathMode_WALK;
  static constexpr PathMode TRAIL = ASTGraphPathModeEnums_PathMode_TRAIL;
  static constexpr PathMode SIMPLE = ASTGraphPathModeEnums_PathMode_SIMPLE;
  static constexpr PathMode ACYCLIC = ASTGraphPathModeEnums_PathMode_ACYCLIC;
  static inline bool PathMode_IsValid(int value) {
    return ASTGraphPathModeEnums_PathMode_IsValid(value);
  }
  static constexpr PathMode PathMode_MIN = ASTGraphPathModeEnums_PathMode_PathMode_MIN;
  static constexpr PathMode PathMode_MAX = ASTGraphPathModeEnums_PathMode_PathMode_MAX;
  static constexpr int PathMode_ARRAYSIZE = ASTGraphPathModeEnums_PathMode_PathMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PathMode_descriptor() {
    return ASTGraphPathModeEnums_PathMode_descriptor();
  }
  template <typename T>
  static inline const std::string& PathMode_Name(T value) {
    return ASTGraphPathModeEnums_PathMode_Name(value);
  }
  static inline bool PathMode_Parse(absl::string_view name, PathMode* value) {
    return ASTGraphPathModeEnums_PathMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTGraphPathModeEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTGraphPathModeEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTGraphNodeTableReferenceEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTGraphNodeTableReferenceEnums) */ {
 public:
  inline ASTGraphNodeTableReferenceEnums() : ASTGraphNodeTableReferenceEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTGraphNodeTableReferenceEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTGraphNodeTableReferenceEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTGraphNodeTableReferenceEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTGraphNodeTableReferenceEnums(const ASTGraphNodeTableReferenceEnums& from) : ASTGraphNodeTableReferenceEnums(nullptr, from) {}
  inline ASTGraphNodeTableReferenceEnums(ASTGraphNodeTableReferenceEnums&& from) noexcept
      : ASTGraphNodeTableReferenceEnums(nullptr, std::move(from)) {}
  inline ASTGraphNodeTableReferenceEnums& operator=(const ASTGraphNodeTableReferenceEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTGraphNodeTableReferenceEnums& operator=(ASTGraphNodeTableReferenceEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTGraphNodeTableReferenceEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTGraphNodeTableReferenceEnums* internal_default_instance() {
    return reinterpret_cast<const ASTGraphNodeTableReferenceEnums*>(
        &_ASTGraphNodeTableReferenceEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(ASTGraphNodeTableReferenceEnums& a, ASTGraphNodeTableReferenceEnums& b) { a.Swap(&b); }
  inline void Swap(ASTGraphNodeTableReferenceEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTGraphNodeTableReferenceEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTGraphNodeTableReferenceEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTGraphNodeTableReferenceEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTGraphNodeTableReferenceEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTGraphNodeTableReferenceEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTGraphNodeTableReferenceEnums"; }

 protected:
  explicit ASTGraphNodeTableReferenceEnums(::google::protobuf::Arena* arena);
  ASTGraphNodeTableReferenceEnums(::google::protobuf::Arena* arena, const ASTGraphNodeTableReferenceEnums& from);
  ASTGraphNodeTableReferenceEnums(::google::protobuf::Arena* arena, ASTGraphNodeTableReferenceEnums&& from) noexcept
      : ASTGraphNodeTableReferenceEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using NodeReferenceType = ASTGraphNodeTableReferenceEnums_NodeReferenceType;
  static constexpr NodeReferenceType NODE_REFERENCE_TYPE_UNSPECIFIED = ASTGraphNodeTableReferenceEnums_NodeReferenceType_NODE_REFERENCE_TYPE_UNSPECIFIED;
  static constexpr NodeReferenceType SOURCE = ASTGraphNodeTableReferenceEnums_NodeReferenceType_SOURCE;
  static constexpr NodeReferenceType DESTINATION = ASTGraphNodeTableReferenceEnums_NodeReferenceType_DESTINATION;
  static inline bool NodeReferenceType_IsValid(int value) {
    return ASTGraphNodeTableReferenceEnums_NodeReferenceType_IsValid(value);
  }
  static constexpr NodeReferenceType NodeReferenceType_MIN = ASTGraphNodeTableReferenceEnums_NodeReferenceType_NodeReferenceType_MIN;
  static constexpr NodeReferenceType NodeReferenceType_MAX = ASTGraphNodeTableReferenceEnums_NodeReferenceType_NodeReferenceType_MAX;
  static constexpr int NodeReferenceType_ARRAYSIZE = ASTGraphNodeTableReferenceEnums_NodeReferenceType_NodeReferenceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* NodeReferenceType_descriptor() {
    return ASTGraphNodeTableReferenceEnums_NodeReferenceType_descriptor();
  }
  template <typename T>
  static inline const std::string& NodeReferenceType_Name(T value) {
    return ASTGraphNodeTableReferenceEnums_NodeReferenceType_Name(value);
  }
  static inline bool NodeReferenceType_Parse(absl::string_view name, NodeReferenceType* value) {
    return ASTGraphNodeTableReferenceEnums_NodeReferenceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTGraphNodeTableReferenceEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTGraphNodeTableReferenceEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTGraphLabelOperationEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTGraphLabelOperationEnums) */ {
 public:
  inline ASTGraphLabelOperationEnums() : ASTGraphLabelOperationEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTGraphLabelOperationEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTGraphLabelOperationEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTGraphLabelOperationEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTGraphLabelOperationEnums(const ASTGraphLabelOperationEnums& from) : ASTGraphLabelOperationEnums(nullptr, from) {}
  inline ASTGraphLabelOperationEnums(ASTGraphLabelOperationEnums&& from) noexcept
      : ASTGraphLabelOperationEnums(nullptr, std::move(from)) {}
  inline ASTGraphLabelOperationEnums& operator=(const ASTGraphLabelOperationEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTGraphLabelOperationEnums& operator=(ASTGraphLabelOperationEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTGraphLabelOperationEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTGraphLabelOperationEnums* internal_default_instance() {
    return reinterpret_cast<const ASTGraphLabelOperationEnums*>(
        &_ASTGraphLabelOperationEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(ASTGraphLabelOperationEnums& a, ASTGraphLabelOperationEnums& b) { a.Swap(&b); }
  inline void Swap(ASTGraphLabelOperationEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTGraphLabelOperationEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTGraphLabelOperationEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTGraphLabelOperationEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTGraphLabelOperationEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTGraphLabelOperationEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTGraphLabelOperationEnums"; }

 protected:
  explicit ASTGraphLabelOperationEnums(::google::protobuf::Arena* arena);
  ASTGraphLabelOperationEnums(::google::protobuf::Arena* arena, const ASTGraphLabelOperationEnums& from);
  ASTGraphLabelOperationEnums(::google::protobuf::Arena* arena, ASTGraphLabelOperationEnums&& from) noexcept
      : ASTGraphLabelOperationEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using OperationType = ASTGraphLabelOperationEnums_OperationType;
  static constexpr OperationType OPERATION_TYPE_UNSPECIFIED = ASTGraphLabelOperationEnums_OperationType_OPERATION_TYPE_UNSPECIFIED;
  static constexpr OperationType NOT = ASTGraphLabelOperationEnums_OperationType_NOT;
  static constexpr OperationType AND = ASTGraphLabelOperationEnums_OperationType_AND;
  static constexpr OperationType OR = ASTGraphLabelOperationEnums_OperationType_OR;
  static inline bool OperationType_IsValid(int value) {
    return ASTGraphLabelOperationEnums_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN = ASTGraphLabelOperationEnums_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX = ASTGraphLabelOperationEnums_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE = ASTGraphLabelOperationEnums_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OperationType_descriptor() {
    return ASTGraphLabelOperationEnums_OperationType_descriptor();
  }
  template <typename T>
  static inline const std::string& OperationType_Name(T value) {
    return ASTGraphLabelOperationEnums_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(absl::string_view name, OperationType* value) {
    return ASTGraphLabelOperationEnums_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTGraphLabelOperationEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTGraphLabelOperationEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTGraphEdgePatternEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTGraphEdgePatternEnums) */ {
 public:
  inline ASTGraphEdgePatternEnums() : ASTGraphEdgePatternEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTGraphEdgePatternEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTGraphEdgePatternEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTGraphEdgePatternEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTGraphEdgePatternEnums(const ASTGraphEdgePatternEnums& from) : ASTGraphEdgePatternEnums(nullptr, from) {}
  inline ASTGraphEdgePatternEnums(ASTGraphEdgePatternEnums&& from) noexcept
      : ASTGraphEdgePatternEnums(nullptr, std::move(from)) {}
  inline ASTGraphEdgePatternEnums& operator=(const ASTGraphEdgePatternEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTGraphEdgePatternEnums& operator=(ASTGraphEdgePatternEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTGraphEdgePatternEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTGraphEdgePatternEnums* internal_default_instance() {
    return reinterpret_cast<const ASTGraphEdgePatternEnums*>(
        &_ASTGraphEdgePatternEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(ASTGraphEdgePatternEnums& a, ASTGraphEdgePatternEnums& b) { a.Swap(&b); }
  inline void Swap(ASTGraphEdgePatternEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTGraphEdgePatternEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTGraphEdgePatternEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTGraphEdgePatternEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTGraphEdgePatternEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTGraphEdgePatternEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTGraphEdgePatternEnums"; }

 protected:
  explicit ASTGraphEdgePatternEnums(::google::protobuf::Arena* arena);
  ASTGraphEdgePatternEnums(::google::protobuf::Arena* arena, const ASTGraphEdgePatternEnums& from);
  ASTGraphEdgePatternEnums(::google::protobuf::Arena* arena, ASTGraphEdgePatternEnums&& from) noexcept
      : ASTGraphEdgePatternEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using EdgeOrientation = ASTGraphEdgePatternEnums_EdgeOrientation;
  static constexpr EdgeOrientation EDGE_ORIENTATION_NOT_SET = ASTGraphEdgePatternEnums_EdgeOrientation_EDGE_ORIENTATION_NOT_SET;
  static constexpr EdgeOrientation ANY = ASTGraphEdgePatternEnums_EdgeOrientation_ANY;
  static constexpr EdgeOrientation LEFT = ASTGraphEdgePatternEnums_EdgeOrientation_LEFT;
  static constexpr EdgeOrientation RIGHT = ASTGraphEdgePatternEnums_EdgeOrientation_RIGHT;
  static inline bool EdgeOrientation_IsValid(int value) {
    return ASTGraphEdgePatternEnums_EdgeOrientation_IsValid(value);
  }
  static constexpr EdgeOrientation EdgeOrientation_MIN = ASTGraphEdgePatternEnums_EdgeOrientation_EdgeOrientation_MIN;
  static constexpr EdgeOrientation EdgeOrientation_MAX = ASTGraphEdgePatternEnums_EdgeOrientation_EdgeOrientation_MAX;
  static constexpr int EdgeOrientation_ARRAYSIZE = ASTGraphEdgePatternEnums_EdgeOrientation_EdgeOrientation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* EdgeOrientation_descriptor() {
    return ASTGraphEdgePatternEnums_EdgeOrientation_descriptor();
  }
  template <typename T>
  static inline const std::string& EdgeOrientation_Name(T value) {
    return ASTGraphEdgePatternEnums_EdgeOrientation_Name(value);
  }
  static inline bool EdgeOrientation_Parse(absl::string_view name, EdgeOrientation* value) {
    return ASTGraphEdgePatternEnums_EdgeOrientation_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTGraphEdgePatternEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTGraphEdgePatternEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTGeneratedColumnInfoEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTGeneratedColumnInfoEnums) */ {
 public:
  inline ASTGeneratedColumnInfoEnums() : ASTGeneratedColumnInfoEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTGeneratedColumnInfoEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTGeneratedColumnInfoEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTGeneratedColumnInfoEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTGeneratedColumnInfoEnums(const ASTGeneratedColumnInfoEnums& from) : ASTGeneratedColumnInfoEnums(nullptr, from) {}
  inline ASTGeneratedColumnInfoEnums(ASTGeneratedColumnInfoEnums&& from) noexcept
      : ASTGeneratedColumnInfoEnums(nullptr, std::move(from)) {}
  inline ASTGeneratedColumnInfoEnums& operator=(const ASTGeneratedColumnInfoEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTGeneratedColumnInfoEnums& operator=(ASTGeneratedColumnInfoEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTGeneratedColumnInfoEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTGeneratedColumnInfoEnums* internal_default_instance() {
    return reinterpret_cast<const ASTGeneratedColumnInfoEnums*>(
        &_ASTGeneratedColumnInfoEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ASTGeneratedColumnInfoEnums& a, ASTGeneratedColumnInfoEnums& b) { a.Swap(&b); }
  inline void Swap(ASTGeneratedColumnInfoEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTGeneratedColumnInfoEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTGeneratedColumnInfoEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTGeneratedColumnInfoEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTGeneratedColumnInfoEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTGeneratedColumnInfoEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTGeneratedColumnInfoEnums"; }

 protected:
  explicit ASTGeneratedColumnInfoEnums(::google::protobuf::Arena* arena);
  ASTGeneratedColumnInfoEnums(::google::protobuf::Arena* arena, const ASTGeneratedColumnInfoEnums& from);
  ASTGeneratedColumnInfoEnums(::google::protobuf::Arena* arena, ASTGeneratedColumnInfoEnums&& from) noexcept
      : ASTGeneratedColumnInfoEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using StoredMode = ASTGeneratedColumnInfoEnums_StoredMode;
  static constexpr StoredMode NON_STORED = ASTGeneratedColumnInfoEnums_StoredMode_NON_STORED;
  static constexpr StoredMode STORED = ASTGeneratedColumnInfoEnums_StoredMode_STORED;
  static constexpr StoredMode STORED_VOLATILE = ASTGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE;
  static inline bool StoredMode_IsValid(int value) {
    return ASTGeneratedColumnInfoEnums_StoredMode_IsValid(value);
  }
  static constexpr StoredMode StoredMode_MIN = ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MIN;
  static constexpr StoredMode StoredMode_MAX = ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX;
  static constexpr int StoredMode_ARRAYSIZE = ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* StoredMode_descriptor() {
    return ASTGeneratedColumnInfoEnums_StoredMode_descriptor();
  }
  template <typename T>
  static inline const std::string& StoredMode_Name(T value) {
    return ASTGeneratedColumnInfoEnums_StoredMode_Name(value);
  }
  static inline bool StoredMode_Parse(absl::string_view name, StoredMode* value) {
    return ASTGeneratedColumnInfoEnums_StoredMode_Parse(name, value);
  }
  using GeneratedMode = ASTGeneratedColumnInfoEnums_GeneratedMode;
  static constexpr GeneratedMode ALWAYS = ASTGeneratedColumnInfoEnums_GeneratedMode_ALWAYS;
  static constexpr GeneratedMode BY_DEFAULT = ASTGeneratedColumnInfoEnums_GeneratedMode_BY_DEFAULT;
  static inline bool GeneratedMode_IsValid(int value) {
    return ASTGeneratedColumnInfoEnums_GeneratedMode_IsValid(value);
  }
  static constexpr GeneratedMode GeneratedMode_MIN = ASTGeneratedColumnInfoEnums_GeneratedMode_GeneratedMode_MIN;
  static constexpr GeneratedMode GeneratedMode_MAX = ASTGeneratedColumnInfoEnums_GeneratedMode_GeneratedMode_MAX;
  static constexpr int GeneratedMode_ARRAYSIZE = ASTGeneratedColumnInfoEnums_GeneratedMode_GeneratedMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* GeneratedMode_descriptor() {
    return ASTGeneratedColumnInfoEnums_GeneratedMode_descriptor();
  }
  template <typename T>
  static inline const std::string& GeneratedMode_Name(T value) {
    return ASTGeneratedColumnInfoEnums_GeneratedMode_Name(value);
  }
  static inline bool GeneratedMode_Parse(absl::string_view name, GeneratedMode* value) {
    return ASTGeneratedColumnInfoEnums_GeneratedMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTGeneratedColumnInfoEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTGeneratedColumnInfoEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTFunctionParameterEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTFunctionParameterEnums) */ {
 public:
  inline ASTFunctionParameterEnums() : ASTFunctionParameterEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTFunctionParameterEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTFunctionParameterEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTFunctionParameterEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTFunctionParameterEnums(const ASTFunctionParameterEnums& from) : ASTFunctionParameterEnums(nullptr, from) {}
  inline ASTFunctionParameterEnums(ASTFunctionParameterEnums&& from) noexcept
      : ASTFunctionParameterEnums(nullptr, std::move(from)) {}
  inline ASTFunctionParameterEnums& operator=(const ASTFunctionParameterEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTFunctionParameterEnums& operator=(ASTFunctionParameterEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTFunctionParameterEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTFunctionParameterEnums* internal_default_instance() {
    return reinterpret_cast<const ASTFunctionParameterEnums*>(
        &_ASTFunctionParameterEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ASTFunctionParameterEnums& a, ASTFunctionParameterEnums& b) { a.Swap(&b); }
  inline void Swap(ASTFunctionParameterEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTFunctionParameterEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTFunctionParameterEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTFunctionParameterEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTFunctionParameterEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTFunctionParameterEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTFunctionParameterEnums"; }

 protected:
  explicit ASTFunctionParameterEnums(::google::protobuf::Arena* arena);
  ASTFunctionParameterEnums(::google::protobuf::Arena* arena, const ASTFunctionParameterEnums& from);
  ASTFunctionParameterEnums(::google::protobuf::Arena* arena, ASTFunctionParameterEnums&& from) noexcept
      : ASTFunctionParameterEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ProcedureParameterMode = ASTFunctionParameterEnums_ProcedureParameterMode;
  static constexpr ProcedureParameterMode NOT_SET = ASTFunctionParameterEnums_ProcedureParameterMode_NOT_SET;
  static constexpr ProcedureParameterMode IN = ASTFunctionParameterEnums_ProcedureParameterMode_IN;
  static constexpr ProcedureParameterMode OUT = ASTFunctionParameterEnums_ProcedureParameterMode_OUT;
  static constexpr ProcedureParameterMode INOUT = ASTFunctionParameterEnums_ProcedureParameterMode_INOUT;
  static inline bool ProcedureParameterMode_IsValid(int value) {
    return ASTFunctionParameterEnums_ProcedureParameterMode_IsValid(value);
  }
  static constexpr ProcedureParameterMode ProcedureParameterMode_MIN = ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MIN;
  static constexpr ProcedureParameterMode ProcedureParameterMode_MAX = ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MAX;
  static constexpr int ProcedureParameterMode_ARRAYSIZE = ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ProcedureParameterMode_descriptor() {
    return ASTFunctionParameterEnums_ProcedureParameterMode_descriptor();
  }
  template <typename T>
  static inline const std::string& ProcedureParameterMode_Name(T value) {
    return ASTFunctionParameterEnums_ProcedureParameterMode_Name(value);
  }
  static inline bool ProcedureParameterMode_Parse(absl::string_view name, ProcedureParameterMode* value) {
    return ASTFunctionParameterEnums_ProcedureParameterMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTFunctionParameterEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTFunctionParameterEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTFunctionCallEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTFunctionCallEnums) */ {
 public:
  inline ASTFunctionCallEnums() : ASTFunctionCallEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTFunctionCallEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTFunctionCallEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTFunctionCallEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTFunctionCallEnums(const ASTFunctionCallEnums& from) : ASTFunctionCallEnums(nullptr, from) {}
  inline ASTFunctionCallEnums(ASTFunctionCallEnums&& from) noexcept
      : ASTFunctionCallEnums(nullptr, std::move(from)) {}
  inline ASTFunctionCallEnums& operator=(const ASTFunctionCallEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTFunctionCallEnums& operator=(ASTFunctionCallEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTFunctionCallEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTFunctionCallEnums* internal_default_instance() {
    return reinterpret_cast<const ASTFunctionCallEnums*>(
        &_ASTFunctionCallEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ASTFunctionCallEnums& a, ASTFunctionCallEnums& b) { a.Swap(&b); }
  inline void Swap(ASTFunctionCallEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTFunctionCallEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTFunctionCallEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTFunctionCallEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTFunctionCallEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTFunctionCallEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTFunctionCallEnums"; }

 protected:
  explicit ASTFunctionCallEnums(::google::protobuf::Arena* arena);
  ASTFunctionCallEnums(::google::protobuf::Arena* arena, const ASTFunctionCallEnums& from);
  ASTFunctionCallEnums(::google::protobuf::Arena* arena, ASTFunctionCallEnums&& from) noexcept
      : ASTFunctionCallEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using NullHandlingModifier = ASTFunctionCallEnums_NullHandlingModifier;
  static constexpr NullHandlingModifier DEFAULT_NULL_HANDLING = ASTFunctionCallEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING;
  static constexpr NullHandlingModifier IGNORE_NULLS = ASTFunctionCallEnums_NullHandlingModifier_IGNORE_NULLS;
  static constexpr NullHandlingModifier RESPECT_NULLS = ASTFunctionCallEnums_NullHandlingModifier_RESPECT_NULLS;
  static inline bool NullHandlingModifier_IsValid(int value) {
    return ASTFunctionCallEnums_NullHandlingModifier_IsValid(value);
  }
  static constexpr NullHandlingModifier NullHandlingModifier_MIN = ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MIN;
  static constexpr NullHandlingModifier NullHandlingModifier_MAX = ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MAX;
  static constexpr int NullHandlingModifier_ARRAYSIZE = ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* NullHandlingModifier_descriptor() {
    return ASTFunctionCallEnums_NullHandlingModifier_descriptor();
  }
  template <typename T>
  static inline const std::string& NullHandlingModifier_Name(T value) {
    return ASTFunctionCallEnums_NullHandlingModifier_Name(value);
  }
  static inline bool NullHandlingModifier_Parse(absl::string_view name, NullHandlingModifier* value) {
    return ASTFunctionCallEnums_NullHandlingModifier_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTFunctionCallEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTFunctionCallEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTForeignKeyReferenceEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTForeignKeyReferenceEnums) */ {
 public:
  inline ASTForeignKeyReferenceEnums() : ASTForeignKeyReferenceEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTForeignKeyReferenceEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTForeignKeyReferenceEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTForeignKeyReferenceEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTForeignKeyReferenceEnums(const ASTForeignKeyReferenceEnums& from) : ASTForeignKeyReferenceEnums(nullptr, from) {}
  inline ASTForeignKeyReferenceEnums(ASTForeignKeyReferenceEnums&& from) noexcept
      : ASTForeignKeyReferenceEnums(nullptr, std::move(from)) {}
  inline ASTForeignKeyReferenceEnums& operator=(const ASTForeignKeyReferenceEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTForeignKeyReferenceEnums& operator=(ASTForeignKeyReferenceEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTForeignKeyReferenceEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTForeignKeyReferenceEnums* internal_default_instance() {
    return reinterpret_cast<const ASTForeignKeyReferenceEnums*>(
        &_ASTForeignKeyReferenceEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(ASTForeignKeyReferenceEnums& a, ASTForeignKeyReferenceEnums& b) { a.Swap(&b); }
  inline void Swap(ASTForeignKeyReferenceEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTForeignKeyReferenceEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTForeignKeyReferenceEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTForeignKeyReferenceEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTForeignKeyReferenceEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTForeignKeyReferenceEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTForeignKeyReferenceEnums"; }

 protected:
  explicit ASTForeignKeyReferenceEnums(::google::protobuf::Arena* arena);
  ASTForeignKeyReferenceEnums(::google::protobuf::Arena* arena, const ASTForeignKeyReferenceEnums& from);
  ASTForeignKeyReferenceEnums(::google::protobuf::Arena* arena, ASTForeignKeyReferenceEnums&& from) noexcept
      : ASTForeignKeyReferenceEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Match = ASTForeignKeyReferenceEnums_Match;
  static constexpr Match SIMPLE = ASTForeignKeyReferenceEnums_Match_SIMPLE;
  static constexpr Match FULL = ASTForeignKeyReferenceEnums_Match_FULL;
  static constexpr Match NOT_DISTINCT = ASTForeignKeyReferenceEnums_Match_NOT_DISTINCT;
  static inline bool Match_IsValid(int value) {
    return ASTForeignKeyReferenceEnums_Match_IsValid(value);
  }
  static constexpr Match Match_MIN = ASTForeignKeyReferenceEnums_Match_Match_MIN;
  static constexpr Match Match_MAX = ASTForeignKeyReferenceEnums_Match_Match_MAX;
  static constexpr int Match_ARRAYSIZE = ASTForeignKeyReferenceEnums_Match_Match_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Match_descriptor() {
    return ASTForeignKeyReferenceEnums_Match_descriptor();
  }
  template <typename T>
  static inline const std::string& Match_Name(T value) {
    return ASTForeignKeyReferenceEnums_Match_Name(value);
  }
  static inline bool Match_Parse(absl::string_view name, Match* value) {
    return ASTForeignKeyReferenceEnums_Match_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTForeignKeyReferenceEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTForeignKeyReferenceEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTForeignKeyActionsEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTForeignKeyActionsEnums) */ {
 public:
  inline ASTForeignKeyActionsEnums() : ASTForeignKeyActionsEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTForeignKeyActionsEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTForeignKeyActionsEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTForeignKeyActionsEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTForeignKeyActionsEnums(const ASTForeignKeyActionsEnums& from) : ASTForeignKeyActionsEnums(nullptr, from) {}
  inline ASTForeignKeyActionsEnums(ASTForeignKeyActionsEnums&& from) noexcept
      : ASTForeignKeyActionsEnums(nullptr, std::move(from)) {}
  inline ASTForeignKeyActionsEnums& operator=(const ASTForeignKeyActionsEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTForeignKeyActionsEnums& operator=(ASTForeignKeyActionsEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTForeignKeyActionsEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTForeignKeyActionsEnums* internal_default_instance() {
    return reinterpret_cast<const ASTForeignKeyActionsEnums*>(
        &_ASTForeignKeyActionsEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(ASTForeignKeyActionsEnums& a, ASTForeignKeyActionsEnums& b) { a.Swap(&b); }
  inline void Swap(ASTForeignKeyActionsEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTForeignKeyActionsEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTForeignKeyActionsEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTForeignKeyActionsEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTForeignKeyActionsEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTForeignKeyActionsEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTForeignKeyActionsEnums"; }

 protected:
  explicit ASTForeignKeyActionsEnums(::google::protobuf::Arena* arena);
  ASTForeignKeyActionsEnums(::google::protobuf::Arena* arena, const ASTForeignKeyActionsEnums& from);
  ASTForeignKeyActionsEnums(::google::protobuf::Arena* arena, ASTForeignKeyActionsEnums&& from) noexcept
      : ASTForeignKeyActionsEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Action = ASTForeignKeyActionsEnums_Action;
  static constexpr Action NO_ACTION = ASTForeignKeyActionsEnums_Action_NO_ACTION;
  static constexpr Action RESTRICT = ASTForeignKeyActionsEnums_Action_RESTRICT;
  static constexpr Action CASCADE = ASTForeignKeyActionsEnums_Action_CASCADE;
  static constexpr Action SET_NULL = ASTForeignKeyActionsEnums_Action_SET_NULL;
  static inline bool Action_IsValid(int value) {
    return ASTForeignKeyActionsEnums_Action_IsValid(value);
  }
  static constexpr Action Action_MIN = ASTForeignKeyActionsEnums_Action_Action_MIN;
  static constexpr Action Action_MAX = ASTForeignKeyActionsEnums_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE = ASTForeignKeyActionsEnums_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Action_descriptor() {
    return ASTForeignKeyActionsEnums_Action_descriptor();
  }
  template <typename T>
  static inline const std::string& Action_Name(T value) {
    return ASTForeignKeyActionsEnums_Action_Name(value);
  }
  static inline bool Action_Parse(absl::string_view name, Action* value) {
    return ASTForeignKeyActionsEnums_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTForeignKeyActionsEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTForeignKeyActionsEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTFilterFieldsArgEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTFilterFieldsArgEnums) */ {
 public:
  inline ASTFilterFieldsArgEnums() : ASTFilterFieldsArgEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTFilterFieldsArgEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTFilterFieldsArgEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTFilterFieldsArgEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTFilterFieldsArgEnums(const ASTFilterFieldsArgEnums& from) : ASTFilterFieldsArgEnums(nullptr, from) {}
  inline ASTFilterFieldsArgEnums(ASTFilterFieldsArgEnums&& from) noexcept
      : ASTFilterFieldsArgEnums(nullptr, std::move(from)) {}
  inline ASTFilterFieldsArgEnums& operator=(const ASTFilterFieldsArgEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTFilterFieldsArgEnums& operator=(ASTFilterFieldsArgEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTFilterFieldsArgEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTFilterFieldsArgEnums* internal_default_instance() {
    return reinterpret_cast<const ASTFilterFieldsArgEnums*>(
        &_ASTFilterFieldsArgEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(ASTFilterFieldsArgEnums& a, ASTFilterFieldsArgEnums& b) { a.Swap(&b); }
  inline void Swap(ASTFilterFieldsArgEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTFilterFieldsArgEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTFilterFieldsArgEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTFilterFieldsArgEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTFilterFieldsArgEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTFilterFieldsArgEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTFilterFieldsArgEnums"; }

 protected:
  explicit ASTFilterFieldsArgEnums(::google::protobuf::Arena* arena);
  ASTFilterFieldsArgEnums(::google::protobuf::Arena* arena, const ASTFilterFieldsArgEnums& from);
  ASTFilterFieldsArgEnums(::google::protobuf::Arena* arena, ASTFilterFieldsArgEnums&& from) noexcept
      : ASTFilterFieldsArgEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using FilterType = ASTFilterFieldsArgEnums_FilterType;
  static constexpr FilterType NOT_SET = ASTFilterFieldsArgEnums_FilterType_NOT_SET;
  static constexpr FilterType INCLUDE = ASTFilterFieldsArgEnums_FilterType_INCLUDE;
  static constexpr FilterType EXCLUDE = ASTFilterFieldsArgEnums_FilterType_EXCLUDE;
  static inline bool FilterType_IsValid(int value) {
    return ASTFilterFieldsArgEnums_FilterType_IsValid(value);
  }
  static constexpr FilterType FilterType_MIN = ASTFilterFieldsArgEnums_FilterType_FilterType_MIN;
  static constexpr FilterType FilterType_MAX = ASTFilterFieldsArgEnums_FilterType_FilterType_MAX;
  static constexpr int FilterType_ARRAYSIZE = ASTFilterFieldsArgEnums_FilterType_FilterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FilterType_descriptor() {
    return ASTFilterFieldsArgEnums_FilterType_descriptor();
  }
  template <typename T>
  static inline const std::string& FilterType_Name(T value) {
    return ASTFilterFieldsArgEnums_FilterType_Name(value);
  }
  static inline bool FilterType_Parse(absl::string_view name, FilterType* value) {
    return ASTFilterFieldsArgEnums_FilterType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTFilterFieldsArgEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTFilterFieldsArgEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTExpressionSubqueryEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTExpressionSubqueryEnums) */ {
 public:
  inline ASTExpressionSubqueryEnums() : ASTExpressionSubqueryEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTExpressionSubqueryEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTExpressionSubqueryEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTExpressionSubqueryEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTExpressionSubqueryEnums(const ASTExpressionSubqueryEnums& from) : ASTExpressionSubqueryEnums(nullptr, from) {}
  inline ASTExpressionSubqueryEnums(ASTExpressionSubqueryEnums&& from) noexcept
      : ASTExpressionSubqueryEnums(nullptr, std::move(from)) {}
  inline ASTExpressionSubqueryEnums& operator=(const ASTExpressionSubqueryEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTExpressionSubqueryEnums& operator=(ASTExpressionSubqueryEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTExpressionSubqueryEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTExpressionSubqueryEnums* internal_default_instance() {
    return reinterpret_cast<const ASTExpressionSubqueryEnums*>(
        &_ASTExpressionSubqueryEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ASTExpressionSubqueryEnums& a, ASTExpressionSubqueryEnums& b) { a.Swap(&b); }
  inline void Swap(ASTExpressionSubqueryEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTExpressionSubqueryEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTExpressionSubqueryEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTExpressionSubqueryEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTExpressionSubqueryEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTExpressionSubqueryEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTExpressionSubqueryEnums"; }

 protected:
  explicit ASTExpressionSubqueryEnums(::google::protobuf::Arena* arena);
  ASTExpressionSubqueryEnums(::google::protobuf::Arena* arena, const ASTExpressionSubqueryEnums& from);
  ASTExpressionSubqueryEnums(::google::protobuf::Arena* arena, ASTExpressionSubqueryEnums&& from) noexcept
      : ASTExpressionSubqueryEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Modifier = ASTExpressionSubqueryEnums_Modifier;
  static constexpr Modifier NONE = ASTExpressionSubqueryEnums_Modifier_NONE;
  static constexpr Modifier ARRAY = ASTExpressionSubqueryEnums_Modifier_ARRAY;
  static constexpr Modifier EXISTS = ASTExpressionSubqueryEnums_Modifier_EXISTS;
  static constexpr Modifier VALUE = ASTExpressionSubqueryEnums_Modifier_VALUE;
  static inline bool Modifier_IsValid(int value) {
    return ASTExpressionSubqueryEnums_Modifier_IsValid(value);
  }
  static constexpr Modifier Modifier_MIN = ASTExpressionSubqueryEnums_Modifier_Modifier_MIN;
  static constexpr Modifier Modifier_MAX = ASTExpressionSubqueryEnums_Modifier_Modifier_MAX;
  static constexpr int Modifier_ARRAYSIZE = ASTExpressionSubqueryEnums_Modifier_Modifier_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Modifier_descriptor() {
    return ASTExpressionSubqueryEnums_Modifier_descriptor();
  }
  template <typename T>
  static inline const std::string& Modifier_Name(T value) {
    return ASTExpressionSubqueryEnums_Modifier_Name(value);
  }
  static inline bool Modifier_Parse(absl::string_view name, Modifier* value) {
    return ASTExpressionSubqueryEnums_Modifier_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTExpressionSubqueryEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTExpressionSubqueryEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTDropStatementEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTDropStatementEnums) */ {
 public:
  inline ASTDropStatementEnums() : ASTDropStatementEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTDropStatementEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTDropStatementEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTDropStatementEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTDropStatementEnums(const ASTDropStatementEnums& from) : ASTDropStatementEnums(nullptr, from) {}
  inline ASTDropStatementEnums(ASTDropStatementEnums&& from) noexcept
      : ASTDropStatementEnums(nullptr, std::move(from)) {}
  inline ASTDropStatementEnums& operator=(const ASTDropStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTDropStatementEnums& operator=(ASTDropStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTDropStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTDropStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTDropStatementEnums*>(
        &_ASTDropStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(ASTDropStatementEnums& a, ASTDropStatementEnums& b) { a.Swap(&b); }
  inline void Swap(ASTDropStatementEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTDropStatementEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTDropStatementEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTDropStatementEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTDropStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTDropStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTDropStatementEnums"; }

 protected:
  explicit ASTDropStatementEnums(::google::protobuf::Arena* arena);
  ASTDropStatementEnums(::google::protobuf::Arena* arena, const ASTDropStatementEnums& from);
  ASTDropStatementEnums(::google::protobuf::Arena* arena, ASTDropStatementEnums&& from) noexcept
      : ASTDropStatementEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using DropMode = ASTDropStatementEnums_DropMode;
  static constexpr DropMode DROP_MODE_UNSPECIFIED = ASTDropStatementEnums_DropMode_DROP_MODE_UNSPECIFIED;
  static constexpr DropMode RESTRICT = ASTDropStatementEnums_DropMode_RESTRICT;
  static constexpr DropMode CASCADE = ASTDropStatementEnums_DropMode_CASCADE;
  static inline bool DropMode_IsValid(int value) {
    return ASTDropStatementEnums_DropMode_IsValid(value);
  }
  static constexpr DropMode DropMode_MIN = ASTDropStatementEnums_DropMode_DropMode_MIN;
  static constexpr DropMode DropMode_MAX = ASTDropStatementEnums_DropMode_DropMode_MAX;
  static constexpr int DropMode_ARRAYSIZE = ASTDropStatementEnums_DropMode_DropMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DropMode_descriptor() {
    return ASTDropStatementEnums_DropMode_descriptor();
  }
  template <typename T>
  static inline const std::string& DropMode_Name(T value) {
    return ASTDropStatementEnums_DropMode_Name(value);
  }
  static inline bool DropMode_Parse(absl::string_view name, DropMode* value) {
    return ASTDropStatementEnums_DropMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTDropStatementEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTDropStatementEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTCreateStatementEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTCreateStatementEnums) */ {
 public:
  inline ASTCreateStatementEnums() : ASTCreateStatementEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTCreateStatementEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTCreateStatementEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTCreateStatementEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTCreateStatementEnums(const ASTCreateStatementEnums& from) : ASTCreateStatementEnums(nullptr, from) {}
  inline ASTCreateStatementEnums(ASTCreateStatementEnums&& from) noexcept
      : ASTCreateStatementEnums(nullptr, std::move(from)) {}
  inline ASTCreateStatementEnums& operator=(const ASTCreateStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTCreateStatementEnums& operator=(ASTCreateStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTCreateStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTCreateStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTCreateStatementEnums*>(
        &_ASTCreateStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ASTCreateStatementEnums& a, ASTCreateStatementEnums& b) { a.Swap(&b); }
  inline void Swap(ASTCreateStatementEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTCreateStatementEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTCreateStatementEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTCreateStatementEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTCreateStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTCreateStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTCreateStatementEnums"; }

 protected:
  explicit ASTCreateStatementEnums(::google::protobuf::Arena* arena);
  ASTCreateStatementEnums(::google::protobuf::Arena* arena, const ASTCreateStatementEnums& from);
  ASTCreateStatementEnums(::google::protobuf::Arena* arena, ASTCreateStatementEnums&& from) noexcept
      : ASTCreateStatementEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Scope = ASTCreateStatementEnums_Scope;
  static constexpr Scope DEFAULT_SCOPE = ASTCreateStatementEnums_Scope_DEFAULT_SCOPE;
  static constexpr Scope PRIVATE = ASTCreateStatementEnums_Scope_PRIVATE;
  static constexpr Scope PUBLIC = ASTCreateStatementEnums_Scope_PUBLIC;
  static constexpr Scope TEMPORARY = ASTCreateStatementEnums_Scope_TEMPORARY;
  static inline bool Scope_IsValid(int value) {
    return ASTCreateStatementEnums_Scope_IsValid(value);
  }
  static constexpr Scope Scope_MIN = ASTCreateStatementEnums_Scope_Scope_MIN;
  static constexpr Scope Scope_MAX = ASTCreateStatementEnums_Scope_Scope_MAX;
  static constexpr int Scope_ARRAYSIZE = ASTCreateStatementEnums_Scope_Scope_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Scope_descriptor() {
    return ASTCreateStatementEnums_Scope_descriptor();
  }
  template <typename T>
  static inline const std::string& Scope_Name(T value) {
    return ASTCreateStatementEnums_Scope_Name(value);
  }
  static inline bool Scope_Parse(absl::string_view name, Scope* value) {
    return ASTCreateStatementEnums_Scope_Parse(name, value);
  }
  using SqlSecurity = ASTCreateStatementEnums_SqlSecurity;
  static constexpr SqlSecurity SQL_SECURITY_UNSPECIFIED = ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED;
  static constexpr SqlSecurity SQL_SECURITY_DEFINER = ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_DEFINER;
  static constexpr SqlSecurity SQL_SECURITY_INVOKER = ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER;
  static inline bool SqlSecurity_IsValid(int value) {
    return ASTCreateStatementEnums_SqlSecurity_IsValid(value);
  }
  static constexpr SqlSecurity SqlSecurity_MIN = ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MIN;
  static constexpr SqlSecurity SqlSecurity_MAX = ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MAX;
  static constexpr int SqlSecurity_ARRAYSIZE = ASTCreateStatementEnums_SqlSecurity_SqlSecurity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SqlSecurity_descriptor() {
    return ASTCreateStatementEnums_SqlSecurity_descriptor();
  }
  template <typename T>
  static inline const std::string& SqlSecurity_Name(T value) {
    return ASTCreateStatementEnums_SqlSecurity_Name(value);
  }
  static inline bool SqlSecurity_Parse(absl::string_view name, SqlSecurity* value) {
    return ASTCreateStatementEnums_SqlSecurity_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTCreateStatementEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTCreateStatementEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTCreateFunctionStmtBaseEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTCreateFunctionStmtBaseEnums) */ {
 public:
  inline ASTCreateFunctionStmtBaseEnums() : ASTCreateFunctionStmtBaseEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTCreateFunctionStmtBaseEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTCreateFunctionStmtBaseEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTCreateFunctionStmtBaseEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTCreateFunctionStmtBaseEnums(const ASTCreateFunctionStmtBaseEnums& from) : ASTCreateFunctionStmtBaseEnums(nullptr, from) {}
  inline ASTCreateFunctionStmtBaseEnums(ASTCreateFunctionStmtBaseEnums&& from) noexcept
      : ASTCreateFunctionStmtBaseEnums(nullptr, std::move(from)) {}
  inline ASTCreateFunctionStmtBaseEnums& operator=(const ASTCreateFunctionStmtBaseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTCreateFunctionStmtBaseEnums& operator=(ASTCreateFunctionStmtBaseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTCreateFunctionStmtBaseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTCreateFunctionStmtBaseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTCreateFunctionStmtBaseEnums*>(
        &_ASTCreateFunctionStmtBaseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(ASTCreateFunctionStmtBaseEnums& a, ASTCreateFunctionStmtBaseEnums& b) { a.Swap(&b); }
  inline void Swap(ASTCreateFunctionStmtBaseEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTCreateFunctionStmtBaseEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTCreateFunctionStmtBaseEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTCreateFunctionStmtBaseEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTCreateFunctionStmtBaseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTCreateFunctionStmtBaseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTCreateFunctionStmtBaseEnums"; }

 protected:
  explicit ASTCreateFunctionStmtBaseEnums(::google::protobuf::Arena* arena);
  ASTCreateFunctionStmtBaseEnums(::google::protobuf::Arena* arena, const ASTCreateFunctionStmtBaseEnums& from);
  ASTCreateFunctionStmtBaseEnums(::google::protobuf::Arena* arena, ASTCreateFunctionStmtBaseEnums&& from) noexcept
      : ASTCreateFunctionStmtBaseEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using DeterminismLevel = ASTCreateFunctionStmtBaseEnums_DeterminismLevel;
  static constexpr DeterminismLevel DETERMINISM_UNSPECIFIED = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED;
  static constexpr DeterminismLevel DETERMINISTIC = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISTIC;
  static constexpr DeterminismLevel NOT_DETERMINISTIC = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_NOT_DETERMINISTIC;
  static constexpr DeterminismLevel IMMUTABLE = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IMMUTABLE;
  static constexpr DeterminismLevel STABLE = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_STABLE;
  static constexpr DeterminismLevel VOLATILE = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_VOLATILE;
  static inline bool DeterminismLevel_IsValid(int value) {
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IsValid(value);
  }
  static constexpr DeterminismLevel DeterminismLevel_MIN = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MIN;
  static constexpr DeterminismLevel DeterminismLevel_MAX = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MAX;
  static constexpr int DeterminismLevel_ARRAYSIZE = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DeterminismLevel_descriptor() {
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor();
  }
  template <typename T>
  static inline const std::string& DeterminismLevel_Name(T value) {
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Name(value);
  }
  static inline bool DeterminismLevel_Parse(absl::string_view name, DeterminismLevel* value) {
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTCreateFunctionStmtBaseEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTCreateFunctionStmtBaseEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTColumnPositionEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTColumnPositionEnums) */ {
 public:
  inline ASTColumnPositionEnums() : ASTColumnPositionEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTColumnPositionEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTColumnPositionEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTColumnPositionEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTColumnPositionEnums(const ASTColumnPositionEnums& from) : ASTColumnPositionEnums(nullptr, from) {}
  inline ASTColumnPositionEnums(ASTColumnPositionEnums&& from) noexcept
      : ASTColumnPositionEnums(nullptr, std::move(from)) {}
  inline ASTColumnPositionEnums& operator=(const ASTColumnPositionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTColumnPositionEnums& operator=(ASTColumnPositionEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTColumnPositionEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTColumnPositionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTColumnPositionEnums*>(
        &_ASTColumnPositionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ASTColumnPositionEnums& a, ASTColumnPositionEnums& b) { a.Swap(&b); }
  inline void Swap(ASTColumnPositionEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTColumnPositionEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTColumnPositionEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTColumnPositionEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTColumnPositionEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTColumnPositionEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTColumnPositionEnums"; }

 protected:
  explicit ASTColumnPositionEnums(::google::protobuf::Arena* arena);
  ASTColumnPositionEnums(::google::protobuf::Arena* arena, const ASTColumnPositionEnums& from);
  ASTColumnPositionEnums(::google::protobuf::Arena* arena, ASTColumnPositionEnums&& from) noexcept
      : ASTColumnPositionEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RelativePositionType = ASTColumnPositionEnums_RelativePositionType;
  static constexpr RelativePositionType PRECEDING = ASTColumnPositionEnums_RelativePositionType_PRECEDING;
  static constexpr RelativePositionType FOLLOWING = ASTColumnPositionEnums_RelativePositionType_FOLLOWING;
  static inline bool RelativePositionType_IsValid(int value) {
    return ASTColumnPositionEnums_RelativePositionType_IsValid(value);
  }
  static constexpr RelativePositionType RelativePositionType_MIN = ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MIN;
  static constexpr RelativePositionType RelativePositionType_MAX = ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MAX;
  static constexpr int RelativePositionType_ARRAYSIZE = ASTColumnPositionEnums_RelativePositionType_RelativePositionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RelativePositionType_descriptor() {
    return ASTColumnPositionEnums_RelativePositionType_descriptor();
  }
  template <typename T>
  static inline const std::string& RelativePositionType_Name(T value) {
    return ASTColumnPositionEnums_RelativePositionType_Name(value);
  }
  static inline bool RelativePositionType_Parse(absl::string_view name, RelativePositionType* value) {
    return ASTColumnPositionEnums_RelativePositionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTColumnPositionEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTColumnPositionEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTBreakContinueStatementEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTBreakContinueStatementEnums) */ {
 public:
  inline ASTBreakContinueStatementEnums() : ASTBreakContinueStatementEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTBreakContinueStatementEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTBreakContinueStatementEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTBreakContinueStatementEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTBreakContinueStatementEnums(const ASTBreakContinueStatementEnums& from) : ASTBreakContinueStatementEnums(nullptr, from) {}
  inline ASTBreakContinueStatementEnums(ASTBreakContinueStatementEnums&& from) noexcept
      : ASTBreakContinueStatementEnums(nullptr, std::move(from)) {}
  inline ASTBreakContinueStatementEnums& operator=(const ASTBreakContinueStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTBreakContinueStatementEnums& operator=(ASTBreakContinueStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTBreakContinueStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTBreakContinueStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTBreakContinueStatementEnums*>(
        &_ASTBreakContinueStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(ASTBreakContinueStatementEnums& a, ASTBreakContinueStatementEnums& b) { a.Swap(&b); }
  inline void Swap(ASTBreakContinueStatementEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTBreakContinueStatementEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTBreakContinueStatementEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTBreakContinueStatementEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTBreakContinueStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTBreakContinueStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTBreakContinueStatementEnums"; }

 protected:
  explicit ASTBreakContinueStatementEnums(::google::protobuf::Arena* arena);
  ASTBreakContinueStatementEnums(::google::protobuf::Arena* arena, const ASTBreakContinueStatementEnums& from);
  ASTBreakContinueStatementEnums(::google::protobuf::Arena* arena, ASTBreakContinueStatementEnums&& from) noexcept
      : ASTBreakContinueStatementEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using BreakContinueKeyword = ASTBreakContinueStatementEnums_BreakContinueKeyword;
  static constexpr BreakContinueKeyword BREAK = ASTBreakContinueStatementEnums_BreakContinueKeyword_BREAK;
  static constexpr BreakContinueKeyword LEAVE = ASTBreakContinueStatementEnums_BreakContinueKeyword_LEAVE;
  static constexpr BreakContinueKeyword CONTINUE = ASTBreakContinueStatementEnums_BreakContinueKeyword_CONTINUE;
  static constexpr BreakContinueKeyword ITERATE = ASTBreakContinueStatementEnums_BreakContinueKeyword_ITERATE;
  static inline bool BreakContinueKeyword_IsValid(int value) {
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_IsValid(value);
  }
  static constexpr BreakContinueKeyword BreakContinueKeyword_MIN = ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MIN;
  static constexpr BreakContinueKeyword BreakContinueKeyword_MAX = ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MAX;
  static constexpr int BreakContinueKeyword_ARRAYSIZE = ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BreakContinueKeyword_descriptor() {
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor();
  }
  template <typename T>
  static inline const std::string& BreakContinueKeyword_Name(T value) {
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_Name(value);
  }
  static inline bool BreakContinueKeyword_Parse(absl::string_view name, BreakContinueKeyword* value) {
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTBreakContinueStatementEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTBreakContinueStatementEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTBracedConstructorLhsEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTBracedConstructorLhsEnums) */ {
 public:
  inline ASTBracedConstructorLhsEnums() : ASTBracedConstructorLhsEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTBracedConstructorLhsEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTBracedConstructorLhsEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTBracedConstructorLhsEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTBracedConstructorLhsEnums(const ASTBracedConstructorLhsEnums& from) : ASTBracedConstructorLhsEnums(nullptr, from) {}
  inline ASTBracedConstructorLhsEnums(ASTBracedConstructorLhsEnums&& from) noexcept
      : ASTBracedConstructorLhsEnums(nullptr, std::move(from)) {}
  inline ASTBracedConstructorLhsEnums& operator=(const ASTBracedConstructorLhsEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTBracedConstructorLhsEnums& operator=(ASTBracedConstructorLhsEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTBracedConstructorLhsEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTBracedConstructorLhsEnums* internal_default_instance() {
    return reinterpret_cast<const ASTBracedConstructorLhsEnums*>(
        &_ASTBracedConstructorLhsEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(ASTBracedConstructorLhsEnums& a, ASTBracedConstructorLhsEnums& b) { a.Swap(&b); }
  inline void Swap(ASTBracedConstructorLhsEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTBracedConstructorLhsEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTBracedConstructorLhsEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTBracedConstructorLhsEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTBracedConstructorLhsEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTBracedConstructorLhsEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTBracedConstructorLhsEnums"; }

 protected:
  explicit ASTBracedConstructorLhsEnums(::google::protobuf::Arena* arena);
  ASTBracedConstructorLhsEnums(::google::protobuf::Arena* arena, const ASTBracedConstructorLhsEnums& from);
  ASTBracedConstructorLhsEnums(::google::protobuf::Arena* arena, ASTBracedConstructorLhsEnums&& from) noexcept
      : ASTBracedConstructorLhsEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Operation = ASTBracedConstructorLhsEnums_Operation;
  static constexpr Operation UPDATE_SINGLE = ASTBracedConstructorLhsEnums_Operation_UPDATE_SINGLE;
  static constexpr Operation UPDATE_MANY = ASTBracedConstructorLhsEnums_Operation_UPDATE_MANY;
  static constexpr Operation UPDATE_SINGLE_NO_CREATION = ASTBracedConstructorLhsEnums_Operation_UPDATE_SINGLE_NO_CREATION;
  static inline bool Operation_IsValid(int value) {
    return ASTBracedConstructorLhsEnums_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN = ASTBracedConstructorLhsEnums_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX = ASTBracedConstructorLhsEnums_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE = ASTBracedConstructorLhsEnums_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Operation_descriptor() {
    return ASTBracedConstructorLhsEnums_Operation_descriptor();
  }
  template <typename T>
  static inline const std::string& Operation_Name(T value) {
    return ASTBracedConstructorLhsEnums_Operation_Name(value);
  }
  static inline bool Operation_Parse(absl::string_view name, Operation* value) {
    return ASTBracedConstructorLhsEnums_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTBracedConstructorLhsEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTBracedConstructorLhsEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTBinaryExpressionEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTBinaryExpressionEnums) */ {
 public:
  inline ASTBinaryExpressionEnums() : ASTBinaryExpressionEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTBinaryExpressionEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTBinaryExpressionEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTBinaryExpressionEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTBinaryExpressionEnums(const ASTBinaryExpressionEnums& from) : ASTBinaryExpressionEnums(nullptr, from) {}
  inline ASTBinaryExpressionEnums(ASTBinaryExpressionEnums&& from) noexcept
      : ASTBinaryExpressionEnums(nullptr, std::move(from)) {}
  inline ASTBinaryExpressionEnums& operator=(const ASTBinaryExpressionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTBinaryExpressionEnums& operator=(ASTBinaryExpressionEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTBinaryExpressionEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTBinaryExpressionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTBinaryExpressionEnums*>(
        &_ASTBinaryExpressionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ASTBinaryExpressionEnums& a, ASTBinaryExpressionEnums& b) { a.Swap(&b); }
  inline void Swap(ASTBinaryExpressionEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTBinaryExpressionEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTBinaryExpressionEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTBinaryExpressionEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTBinaryExpressionEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTBinaryExpressionEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTBinaryExpressionEnums"; }

 protected:
  explicit ASTBinaryExpressionEnums(::google::protobuf::Arena* arena);
  ASTBinaryExpressionEnums(::google::protobuf::Arena* arena, const ASTBinaryExpressionEnums& from);
  ASTBinaryExpressionEnums(::google::protobuf::Arena* arena, ASTBinaryExpressionEnums&& from) noexcept
      : ASTBinaryExpressionEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Op = ASTBinaryExpressionEnums_Op;
  static constexpr Op NOT_SET = ASTBinaryExpressionEnums_Op_NOT_SET;
  static constexpr Op LIKE = ASTBinaryExpressionEnums_Op_LIKE;
  static constexpr Op IS = ASTBinaryExpressionEnums_Op_IS;
  static constexpr Op EQ = ASTBinaryExpressionEnums_Op_EQ;
  static constexpr Op NE = ASTBinaryExpressionEnums_Op_NE;
  static constexpr Op NE2 = ASTBinaryExpressionEnums_Op_NE2;
  static constexpr Op GT = ASTBinaryExpressionEnums_Op_GT;
  static constexpr Op LT = ASTBinaryExpressionEnums_Op_LT;
  static constexpr Op GE = ASTBinaryExpressionEnums_Op_GE;
  static constexpr Op LE = ASTBinaryExpressionEnums_Op_LE;
  static constexpr Op BITWISE_OR = ASTBinaryExpressionEnums_Op_BITWISE_OR;
  static constexpr Op BITWISE_XOR = ASTBinaryExpressionEnums_Op_BITWISE_XOR;
  static constexpr Op BITWISE_AND = ASTBinaryExpressionEnums_Op_BITWISE_AND;
  static constexpr Op PLUS = ASTBinaryExpressionEnums_Op_PLUS;
  static constexpr Op MINUS = ASTBinaryExpressionEnums_Op_MINUS;
  static constexpr Op MULTIPLY = ASTBinaryExpressionEnums_Op_MULTIPLY;
  static constexpr Op DIVIDE = ASTBinaryExpressionEnums_Op_DIVIDE;
  static constexpr Op CONCAT_OP = ASTBinaryExpressionEnums_Op_CONCAT_OP;
  static constexpr Op DISTINCT = ASTBinaryExpressionEnums_Op_DISTINCT;
  static constexpr Op IS_SOURCE_NODE = ASTBinaryExpressionEnums_Op_IS_SOURCE_NODE;
  static constexpr Op IS_DEST_NODE = ASTBinaryExpressionEnums_Op_IS_DEST_NODE;
  static inline bool Op_IsValid(int value) {
    return ASTBinaryExpressionEnums_Op_IsValid(value);
  }
  static constexpr Op Op_MIN = ASTBinaryExpressionEnums_Op_Op_MIN;
  static constexpr Op Op_MAX = ASTBinaryExpressionEnums_Op_Op_MAX;
  static constexpr int Op_ARRAYSIZE = ASTBinaryExpressionEnums_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Op_descriptor() {
    return ASTBinaryExpressionEnums_Op_descriptor();
  }
  template <typename T>
  static inline const std::string& Op_Name(T value) {
    return ASTBinaryExpressionEnums_Op_Name(value);
  }
  static inline bool Op_Parse(absl::string_view name, Op* value) {
    return ASTBinaryExpressionEnums_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTBinaryExpressionEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTBinaryExpressionEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTAuxLoadDataStatementEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTAuxLoadDataStatementEnums) */ {
 public:
  inline ASTAuxLoadDataStatementEnums() : ASTAuxLoadDataStatementEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTAuxLoadDataStatementEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTAuxLoadDataStatementEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTAuxLoadDataStatementEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTAuxLoadDataStatementEnums(const ASTAuxLoadDataStatementEnums& from) : ASTAuxLoadDataStatementEnums(nullptr, from) {}
  inline ASTAuxLoadDataStatementEnums(ASTAuxLoadDataStatementEnums&& from) noexcept
      : ASTAuxLoadDataStatementEnums(nullptr, std::move(from)) {}
  inline ASTAuxLoadDataStatementEnums& operator=(const ASTAuxLoadDataStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTAuxLoadDataStatementEnums& operator=(ASTAuxLoadDataStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTAuxLoadDataStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTAuxLoadDataStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTAuxLoadDataStatementEnums*>(
        &_ASTAuxLoadDataStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(ASTAuxLoadDataStatementEnums& a, ASTAuxLoadDataStatementEnums& b) { a.Swap(&b); }
  inline void Swap(ASTAuxLoadDataStatementEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTAuxLoadDataStatementEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTAuxLoadDataStatementEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTAuxLoadDataStatementEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTAuxLoadDataStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTAuxLoadDataStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTAuxLoadDataStatementEnums"; }

 protected:
  explicit ASTAuxLoadDataStatementEnums(::google::protobuf::Arena* arena);
  ASTAuxLoadDataStatementEnums(::google::protobuf::Arena* arena, const ASTAuxLoadDataStatementEnums& from);
  ASTAuxLoadDataStatementEnums(::google::protobuf::Arena* arena, ASTAuxLoadDataStatementEnums&& from) noexcept
      : ASTAuxLoadDataStatementEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using InsertionMode = ASTAuxLoadDataStatementEnums_InsertionMode;
  static constexpr InsertionMode NOT_SET = ASTAuxLoadDataStatementEnums_InsertionMode_NOT_SET;
  static constexpr InsertionMode APPEND = ASTAuxLoadDataStatementEnums_InsertionMode_APPEND;
  static constexpr InsertionMode OVERWRITE = ASTAuxLoadDataStatementEnums_InsertionMode_OVERWRITE;
  static inline bool InsertionMode_IsValid(int value) {
    return ASTAuxLoadDataStatementEnums_InsertionMode_IsValid(value);
  }
  static constexpr InsertionMode InsertionMode_MIN = ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MIN;
  static constexpr InsertionMode InsertionMode_MAX = ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MAX;
  static constexpr int InsertionMode_ARRAYSIZE = ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* InsertionMode_descriptor() {
    return ASTAuxLoadDataStatementEnums_InsertionMode_descriptor();
  }
  template <typename T>
  static inline const std::string& InsertionMode_Name(T value) {
    return ASTAuxLoadDataStatementEnums_InsertionMode_Name(value);
  }
  static inline bool InsertionMode_Parse(absl::string_view name, InsertionMode* value) {
    return ASTAuxLoadDataStatementEnums_InsertionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTAuxLoadDataStatementEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTAuxLoadDataStatementEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTAnySomeAllOpEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTAnySomeAllOpEnums) */ {
 public:
  inline ASTAnySomeAllOpEnums() : ASTAnySomeAllOpEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTAnySomeAllOpEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTAnySomeAllOpEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTAnySomeAllOpEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTAnySomeAllOpEnums(const ASTAnySomeAllOpEnums& from) : ASTAnySomeAllOpEnums(nullptr, from) {}
  inline ASTAnySomeAllOpEnums(ASTAnySomeAllOpEnums&& from) noexcept
      : ASTAnySomeAllOpEnums(nullptr, std::move(from)) {}
  inline ASTAnySomeAllOpEnums& operator=(const ASTAnySomeAllOpEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTAnySomeAllOpEnums& operator=(ASTAnySomeAllOpEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTAnySomeAllOpEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTAnySomeAllOpEnums* internal_default_instance() {
    return reinterpret_cast<const ASTAnySomeAllOpEnums*>(
        &_ASTAnySomeAllOpEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ASTAnySomeAllOpEnums& a, ASTAnySomeAllOpEnums& b) { a.Swap(&b); }
  inline void Swap(ASTAnySomeAllOpEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTAnySomeAllOpEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTAnySomeAllOpEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTAnySomeAllOpEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTAnySomeAllOpEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTAnySomeAllOpEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTAnySomeAllOpEnums"; }

 protected:
  explicit ASTAnySomeAllOpEnums(::google::protobuf::Arena* arena);
  ASTAnySomeAllOpEnums(::google::protobuf::Arena* arena, const ASTAnySomeAllOpEnums& from);
  ASTAnySomeAllOpEnums(::google::protobuf::Arena* arena, ASTAnySomeAllOpEnums&& from) noexcept
      : ASTAnySomeAllOpEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Op = ASTAnySomeAllOpEnums_Op;
  static constexpr Op kUninitialized = ASTAnySomeAllOpEnums_Op_kUninitialized;
  static constexpr Op kAny = ASTAnySomeAllOpEnums_Op_kAny;
  static constexpr Op kSome = ASTAnySomeAllOpEnums_Op_kSome;
  static constexpr Op kAll = ASTAnySomeAllOpEnums_Op_kAll;
  static inline bool Op_IsValid(int value) {
    return ASTAnySomeAllOpEnums_Op_IsValid(value);
  }
  static constexpr Op Op_MIN = ASTAnySomeAllOpEnums_Op_Op_MIN;
  static constexpr Op Op_MAX = ASTAnySomeAllOpEnums_Op_Op_MAX;
  static constexpr int Op_ARRAYSIZE = ASTAnySomeAllOpEnums_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Op_descriptor() {
    return ASTAnySomeAllOpEnums_Op_descriptor();
  }
  template <typename T>
  static inline const std::string& Op_Name(T value) {
    return ASTAnySomeAllOpEnums_Op_Name(value);
  }
  static inline bool Op_Parse(absl::string_view name, Op* value) {
    return ASTAnySomeAllOpEnums_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTAnySomeAllOpEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTAnySomeAllOpEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTAlterIndexStatementEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTAlterIndexStatementEnums) */ {
 public:
  inline ASTAlterIndexStatementEnums() : ASTAlterIndexStatementEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTAlterIndexStatementEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTAlterIndexStatementEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTAlterIndexStatementEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTAlterIndexStatementEnums(const ASTAlterIndexStatementEnums& from) : ASTAlterIndexStatementEnums(nullptr, from) {}
  inline ASTAlterIndexStatementEnums(ASTAlterIndexStatementEnums&& from) noexcept
      : ASTAlterIndexStatementEnums(nullptr, std::move(from)) {}
  inline ASTAlterIndexStatementEnums& operator=(const ASTAlterIndexStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTAlterIndexStatementEnums& operator=(ASTAlterIndexStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTAlterIndexStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTAlterIndexStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTAlterIndexStatementEnums*>(
        &_ASTAlterIndexStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(ASTAlterIndexStatementEnums& a, ASTAlterIndexStatementEnums& b) { a.Swap(&b); }
  inline void Swap(ASTAlterIndexStatementEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTAlterIndexStatementEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTAlterIndexStatementEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTAlterIndexStatementEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTAlterIndexStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTAlterIndexStatementEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTAlterIndexStatementEnums"; }

 protected:
  explicit ASTAlterIndexStatementEnums(::google::protobuf::Arena* arena);
  ASTAlterIndexStatementEnums(::google::protobuf::Arena* arena, const ASTAlterIndexStatementEnums& from);
  ASTAlterIndexStatementEnums(::google::protobuf::Arena* arena, ASTAlterIndexStatementEnums&& from) noexcept
      : ASTAlterIndexStatementEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using IndexType = ASTAlterIndexStatementEnums_IndexType;
  static constexpr IndexType INDEX_DEFAULT = ASTAlterIndexStatementEnums_IndexType_INDEX_DEFAULT;
  static constexpr IndexType INDEX_SEARCH = ASTAlterIndexStatementEnums_IndexType_INDEX_SEARCH;
  static constexpr IndexType INDEX_VECTOR = ASTAlterIndexStatementEnums_IndexType_INDEX_VECTOR;
  static inline bool IndexType_IsValid(int value) {
    return ASTAlterIndexStatementEnums_IndexType_IsValid(value);
  }
  static constexpr IndexType IndexType_MIN = ASTAlterIndexStatementEnums_IndexType_IndexType_MIN;
  static constexpr IndexType IndexType_MAX = ASTAlterIndexStatementEnums_IndexType_IndexType_MAX;
  static constexpr int IndexType_ARRAYSIZE = ASTAlterIndexStatementEnums_IndexType_IndexType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* IndexType_descriptor() {
    return ASTAlterIndexStatementEnums_IndexType_descriptor();
  }
  template <typename T>
  static inline const std::string& IndexType_Name(T value) {
    return ASTAlterIndexStatementEnums_IndexType_Name(value);
  }
  static inline bool IndexType_Parse(absl::string_view name, IndexType* value) {
    return ASTAlterIndexStatementEnums_IndexType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTAlterIndexStatementEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTAlterIndexStatementEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTAfterMatchSkipClauseEnums final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:googlesql.ASTAfterMatchSkipClauseEnums) */ {
 public:
  inline ASTAfterMatchSkipClauseEnums() : ASTAfterMatchSkipClauseEnums(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASTAfterMatchSkipClauseEnums* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASTAfterMatchSkipClauseEnums));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASTAfterMatchSkipClauseEnums(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASTAfterMatchSkipClauseEnums(const ASTAfterMatchSkipClauseEnums& from) : ASTAfterMatchSkipClauseEnums(nullptr, from) {}
  inline ASTAfterMatchSkipClauseEnums(ASTAfterMatchSkipClauseEnums&& from) noexcept
      : ASTAfterMatchSkipClauseEnums(nullptr, std::move(from)) {}
  inline ASTAfterMatchSkipClauseEnums& operator=(const ASTAfterMatchSkipClauseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTAfterMatchSkipClauseEnums& operator=(ASTAfterMatchSkipClauseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTAfterMatchSkipClauseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTAfterMatchSkipClauseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTAfterMatchSkipClauseEnums*>(
        &_ASTAfterMatchSkipClauseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(ASTAfterMatchSkipClauseEnums& a, ASTAfterMatchSkipClauseEnums& b) { a.Swap(&b); }
  inline void Swap(ASTAfterMatchSkipClauseEnums* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTAfterMatchSkipClauseEnums* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTAfterMatchSkipClauseEnums* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ASTAfterMatchSkipClauseEnums>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTAfterMatchSkipClauseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTAfterMatchSkipClauseEnums& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "googlesql.ASTAfterMatchSkipClauseEnums"; }

 protected:
  explicit ASTAfterMatchSkipClauseEnums(::google::protobuf::Arena* arena);
  ASTAfterMatchSkipClauseEnums(::google::protobuf::Arena* arena, const ASTAfterMatchSkipClauseEnums& from);
  ASTAfterMatchSkipClauseEnums(::google::protobuf::Arena* arena, ASTAfterMatchSkipClauseEnums&& from) noexcept
      : ASTAfterMatchSkipClauseEnums(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using AfterMatchSkipTargetType = ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType;
  static constexpr AfterMatchSkipTargetType AFTER_MATCH_SKIP_TARGET_UNSPECIFIED = ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_AFTER_MATCH_SKIP_TARGET_UNSPECIFIED;
  static constexpr AfterMatchSkipTargetType PAST_LAST_ROW = ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_PAST_LAST_ROW;
  static constexpr AfterMatchSkipTargetType TO_NEXT_ROW = ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_TO_NEXT_ROW;
  static inline bool AfterMatchSkipTargetType_IsValid(int value) {
    return ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_IsValid(value);
  }
  static constexpr AfterMatchSkipTargetType AfterMatchSkipTargetType_MIN = ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_AfterMatchSkipTargetType_MIN;
  static constexpr AfterMatchSkipTargetType AfterMatchSkipTargetType_MAX = ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_AfterMatchSkipTargetType_MAX;
  static constexpr int AfterMatchSkipTargetType_ARRAYSIZE = ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_AfterMatchSkipTargetType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AfterMatchSkipTargetType_descriptor() {
    return ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_descriptor();
  }
  template <typename T>
  static inline const std::string& AfterMatchSkipTargetType_Name(T value) {
    return ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_Name(value);
  }
  static inline bool AfterMatchSkipTargetType_Parse(absl::string_view name, AfterMatchSkipTargetType* value) {
    return ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:googlesql.ASTAfterMatchSkipClauseEnums)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASTAfterMatchSkipClauseEnums& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_googlesql_2fparser_2fast_5fenums_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ASTBinaryExpressionEnums

// -------------------------------------------------------------------

// ASTOptionsEntryEnums

// -------------------------------------------------------------------

// ASTOrderingExpressionEnums

// -------------------------------------------------------------------

// ASTJoinEnums

// -------------------------------------------------------------------

// ASTSelectAsEnums

// -------------------------------------------------------------------

// ASTFunctionCallEnums

// -------------------------------------------------------------------

// ASTExpressionSubqueryEnums

// -------------------------------------------------------------------

// ASTHavingModifierEnums

// -------------------------------------------------------------------

// ASTSetOperationEnums

// -------------------------------------------------------------------

// ASTUnaryExpressionEnums

// -------------------------------------------------------------------

// ASTWindowFrameEnums

// -------------------------------------------------------------------

// ASTWindowFrameExprEnums

// -------------------------------------------------------------------

// ASTAnySomeAllOpEnums

// -------------------------------------------------------------------

// ASTTransactionReadWriteModeEnums

// -------------------------------------------------------------------

// ASTImportStatementEnums

// -------------------------------------------------------------------

// ASTUnpivotClauseEnums

// -------------------------------------------------------------------

// ASTCreateStatementEnums

// -------------------------------------------------------------------

// ASTFunctionParameterEnums

// -------------------------------------------------------------------

// ASTTemplatedParameterTypeEnums

// -------------------------------------------------------------------

// ASTGeneratedColumnInfoEnums

// -------------------------------------------------------------------

// ASTColumnPositionEnums

// -------------------------------------------------------------------

// ASTInsertStatementEnums

// -------------------------------------------------------------------

// ASTOnConflictClauseEnums

// -------------------------------------------------------------------

// ASTMergeActionEnums

// -------------------------------------------------------------------

// ASTMergeWhenClauseEnums

// -------------------------------------------------------------------

// ASTFilterFieldsArgEnums

// -------------------------------------------------------------------

// ASTSampleSizeEnums

// -------------------------------------------------------------------

// ASTForeignKeyActionsEnums

// -------------------------------------------------------------------

// ASTForeignKeyReferenceEnums

// -------------------------------------------------------------------

// ASTBreakContinueStatementEnums

// -------------------------------------------------------------------

// ASTDropStatementEnums

// -------------------------------------------------------------------

// ASTCreateFunctionStmtBaseEnums

// -------------------------------------------------------------------

// ASTAuxLoadDataStatementEnums

// -------------------------------------------------------------------

// ASTSpannerInterleaveClauseEnums

// -------------------------------------------------------------------

// ASTAfterMatchSkipClauseEnums

// -------------------------------------------------------------------

// ASTRowPatternAnchorEnums

// -------------------------------------------------------------------

// ASTRowPatternOperationEnums

// -------------------------------------------------------------------

// ASTSymbolQuantifierEnums

// -------------------------------------------------------------------

// ASTGraphNodeTableReferenceEnums

// -------------------------------------------------------------------

// ASTGraphLabelOperationEnums

// -------------------------------------------------------------------

// ASTGraphEdgePatternEnums

// -------------------------------------------------------------------

// ASTGraphPathModeEnums

// -------------------------------------------------------------------

// ASTGraphPathSearchPrefixEnums

// -------------------------------------------------------------------

// ASTLockModeEnums

// -------------------------------------------------------------------

// ASTBracedConstructorLhsEnums

// -------------------------------------------------------------------

// ASTAlterIndexStatementEnums

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace googlesql


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::googlesql::ASTBinaryExpressionEnums_Op> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTBinaryExpressionEnums_Op>() {
  return ::googlesql::ASTBinaryExpressionEnums_Op_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTOptionsEntryEnums_AssignmentOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTOptionsEntryEnums_AssignmentOp>() {
  return ::googlesql::ASTOptionsEntryEnums_AssignmentOp_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTOrderingExpressionEnums_OrderingSpec> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTOrderingExpressionEnums_OrderingSpec>() {
  return ::googlesql::ASTOrderingExpressionEnums_OrderingSpec_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTJoinEnums_JoinType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTJoinEnums_JoinType>() {
  return ::googlesql::ASTJoinEnums_JoinType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTJoinEnums_JoinHint> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTJoinEnums_JoinHint>() {
  return ::googlesql::ASTJoinEnums_JoinHint_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTSelectAsEnums_AsMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTSelectAsEnums_AsMode>() {
  return ::googlesql::ASTSelectAsEnums_AsMode_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTFunctionCallEnums_NullHandlingModifier> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTFunctionCallEnums_NullHandlingModifier>() {
  return ::googlesql::ASTFunctionCallEnums_NullHandlingModifier_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTExpressionSubqueryEnums_Modifier> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTExpressionSubqueryEnums_Modifier>() {
  return ::googlesql::ASTExpressionSubqueryEnums_Modifier_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTHavingModifierEnums_ModifierKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTHavingModifierEnums_ModifierKind>() {
  return ::googlesql::ASTHavingModifierEnums_ModifierKind_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTSetOperationEnums_OperationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTSetOperationEnums_OperationType>() {
  return ::googlesql::ASTSetOperationEnums_OperationType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTSetOperationEnums_AllOrDistinct> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTSetOperationEnums_AllOrDistinct>() {
  return ::googlesql::ASTSetOperationEnums_AllOrDistinct_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTSetOperationEnums_ColumnMatchMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTSetOperationEnums_ColumnMatchMode>() {
  return ::googlesql::ASTSetOperationEnums_ColumnMatchMode_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTSetOperationEnums_ColumnPropagationMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTSetOperationEnums_ColumnPropagationMode>() {
  return ::googlesql::ASTSetOperationEnums_ColumnPropagationMode_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTUnaryExpressionEnums_Op> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTUnaryExpressionEnums_Op>() {
  return ::googlesql::ASTUnaryExpressionEnums_Op_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTWindowFrameEnums_FrameUnit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTWindowFrameEnums_FrameUnit>() {
  return ::googlesql::ASTWindowFrameEnums_FrameUnit_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTWindowFrameExprEnums_BoundaryType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTWindowFrameExprEnums_BoundaryType>() {
  return ::googlesql::ASTWindowFrameExprEnums_BoundaryType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTAnySomeAllOpEnums_Op> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTAnySomeAllOpEnums_Op>() {
  return ::googlesql::ASTAnySomeAllOpEnums_Op_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTTransactionReadWriteModeEnums_Mode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTTransactionReadWriteModeEnums_Mode>() {
  return ::googlesql::ASTTransactionReadWriteModeEnums_Mode_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTImportStatementEnums_ImportKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTImportStatementEnums_ImportKind>() {
  return ::googlesql::ASTImportStatementEnums_ImportKind_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTUnpivotClauseEnums_NullFilter> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTUnpivotClauseEnums_NullFilter>() {
  return ::googlesql::ASTUnpivotClauseEnums_NullFilter_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTCreateStatementEnums_Scope> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTCreateStatementEnums_Scope>() {
  return ::googlesql::ASTCreateStatementEnums_Scope_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTCreateStatementEnums_SqlSecurity> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTCreateStatementEnums_SqlSecurity>() {
  return ::googlesql::ASTCreateStatementEnums_SqlSecurity_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTFunctionParameterEnums_ProcedureParameterMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTFunctionParameterEnums_ProcedureParameterMode>() {
  return ::googlesql::ASTFunctionParameterEnums_ProcedureParameterMode_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTTemplatedParameterTypeEnums_TemplatedTypeKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTTemplatedParameterTypeEnums_TemplatedTypeKind>() {
  return ::googlesql::ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTGeneratedColumnInfoEnums_StoredMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTGeneratedColumnInfoEnums_StoredMode>() {
  return ::googlesql::ASTGeneratedColumnInfoEnums_StoredMode_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTGeneratedColumnInfoEnums_GeneratedMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTGeneratedColumnInfoEnums_GeneratedMode>() {
  return ::googlesql::ASTGeneratedColumnInfoEnums_GeneratedMode_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTColumnPositionEnums_RelativePositionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTColumnPositionEnums_RelativePositionType>() {
  return ::googlesql::ASTColumnPositionEnums_RelativePositionType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTInsertStatementEnums_InsertMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTInsertStatementEnums_InsertMode>() {
  return ::googlesql::ASTInsertStatementEnums_InsertMode_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTInsertStatementEnums_ParseProgress> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTInsertStatementEnums_ParseProgress>() {
  return ::googlesql::ASTInsertStatementEnums_ParseProgress_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTOnConflictClauseEnums_ConflictAction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTOnConflictClauseEnums_ConflictAction>() {
  return ::googlesql::ASTOnConflictClauseEnums_ConflictAction_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTMergeActionEnums_ActionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTMergeActionEnums_ActionType>() {
  return ::googlesql::ASTMergeActionEnums_ActionType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTMergeWhenClauseEnums_MatchType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTMergeWhenClauseEnums_MatchType>() {
  return ::googlesql::ASTMergeWhenClauseEnums_MatchType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTFilterFieldsArgEnums_FilterType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTFilterFieldsArgEnums_FilterType>() {
  return ::googlesql::ASTFilterFieldsArgEnums_FilterType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTSampleSizeEnums_Unit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTSampleSizeEnums_Unit>() {
  return ::googlesql::ASTSampleSizeEnums_Unit_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTForeignKeyActionsEnums_Action> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTForeignKeyActionsEnums_Action>() {
  return ::googlesql::ASTForeignKeyActionsEnums_Action_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTForeignKeyReferenceEnums_Match> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTForeignKeyReferenceEnums_Match>() {
  return ::googlesql::ASTForeignKeyReferenceEnums_Match_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTBreakContinueStatementEnums_BreakContinueKeyword> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTBreakContinueStatementEnums_BreakContinueKeyword>() {
  return ::googlesql::ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTDropStatementEnums_DropMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTDropStatementEnums_DropMode>() {
  return ::googlesql::ASTDropStatementEnums_DropMode_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTCreateFunctionStmtBaseEnums_DeterminismLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTCreateFunctionStmtBaseEnums_DeterminismLevel>() {
  return ::googlesql::ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTAuxLoadDataStatementEnums_InsertionMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTAuxLoadDataStatementEnums_InsertionMode>() {
  return ::googlesql::ASTAuxLoadDataStatementEnums_InsertionMode_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTSpannerInterleaveClauseEnums_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTSpannerInterleaveClauseEnums_Type>() {
  return ::googlesql::ASTSpannerInterleaveClauseEnums_Type_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType>() {
  return ::googlesql::ASTAfterMatchSkipClauseEnums_AfterMatchSkipTargetType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTRowPatternAnchorEnums_Anchor> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTRowPatternAnchorEnums_Anchor>() {
  return ::googlesql::ASTRowPatternAnchorEnums_Anchor_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTRowPatternOperationEnums_OperationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTRowPatternOperationEnums_OperationType>() {
  return ::googlesql::ASTRowPatternOperationEnums_OperationType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTSymbolQuantifierEnums_Symbol> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTSymbolQuantifierEnums_Symbol>() {
  return ::googlesql::ASTSymbolQuantifierEnums_Symbol_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTGraphNodeTableReferenceEnums_NodeReferenceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTGraphNodeTableReferenceEnums_NodeReferenceType>() {
  return ::googlesql::ASTGraphNodeTableReferenceEnums_NodeReferenceType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTGraphLabelOperationEnums_OperationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTGraphLabelOperationEnums_OperationType>() {
  return ::googlesql::ASTGraphLabelOperationEnums_OperationType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTGraphEdgePatternEnums_EdgeOrientation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTGraphEdgePatternEnums_EdgeOrientation>() {
  return ::googlesql::ASTGraphEdgePatternEnums_EdgeOrientation_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTGraphPathModeEnums_PathMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTGraphPathModeEnums_PathMode>() {
  return ::googlesql::ASTGraphPathModeEnums_PathMode_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTGraphPathSearchPrefixEnums_PathSearchPrefixType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTGraphPathSearchPrefixEnums_PathSearchPrefixType>() {
  return ::googlesql::ASTGraphPathSearchPrefixEnums_PathSearchPrefixType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTLockModeEnums_LockStrengthSpec> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTLockModeEnums_LockStrengthSpec>() {
  return ::googlesql::ASTLockModeEnums_LockStrengthSpec_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTBracedConstructorLhsEnums_Operation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTBracedConstructorLhsEnums_Operation>() {
  return ::googlesql::ASTBracedConstructorLhsEnums_Operation_descriptor();
}
template <>
struct is_proto_enum<::googlesql::ASTAlterIndexStatementEnums_IndexType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::ASTAlterIndexStatementEnums_IndexType>() {
  return ::googlesql::ASTAlterIndexStatementEnums_IndexType_descriptor();
}
template <>
struct is_proto_enum<::googlesql::SchemaObjectKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::googlesql::SchemaObjectKind>() {
  return ::googlesql::SchemaObjectKind_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // googlesql_2fparser_2fast_5fenums_2eproto_2epb_2eh
